// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DrillData.proto

#include "DrillData.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TorqData {
PROTOBUF_CONSTEXPR ShowInfo::ShowInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.strvalue_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShowInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowInfoDefaultTypeInternal() {}
  union {
    ShowInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowInfoDefaultTypeInternal _ShowInfo_default_instance_;
PROTOBUF_CONSTEXPR Torque::Torque(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ftorque_)*/{}
  , /*decltype(_impl_.frpm_)*/{}
  , /*decltype(_impl_.tshow_)*/{}
  , /*decltype(_impl_.dwdelplus_)*/{}
  , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
  , /*decltype(_impl_.llcoltime_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strmemo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strremark_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.coltime_)*/uint64_t{0u}
  , /*decltype(_impl_.dwseqno_)*/0
  , /*decltype(_impl_.dwquality_)*/0
  , /*decltype(_impl_.fmaxtorq_)*/0
  , /*decltype(_impl_.dwtotalplus_)*/0
  , /*decltype(_impl_.dwcolinter_)*/0
  , /*decltype(_impl_.dwver_)*/0
  , /*decltype(_impl_.btoolbuck_)*/false
  , /*decltype(_impl_.bbreakout_)*/false
  , /*decltype(_impl_.fmaxlimit_)*/0
  , /*decltype(_impl_.fcontrol_)*/0
  , /*decltype(_impl_.fshow_)*/0
  , /*decltype(_impl_.fopttorq_)*/0
  , /*decltype(_impl_.fmaxcir_)*/0
  , /*decltype(_impl_.fuppercir_)*/0
  , /*decltype(_impl_.fcontrolcir_)*/0
  , /*decltype(_impl_.flowercir_)*/0
  , /*decltype(_impl_.dwtorqunit_)*/0
  , /*decltype(_impl_.dwmakeuppnt_)*/0
  , /*decltype(_impl_.fplus_)*/0
  , /*decltype(_impl_.fmaxrpm_)*/0
  , /*decltype(_impl_.fcut_)*/0
  , /*decltype(_impl_.frpmadj_)*/0
  , /*decltype(_impl_.fmulti_)*/0
  , /*decltype(_impl_.fmakeupdur_)*/0
  , /*decltype(_impl_.breakouttime_)*/uint64_t{0u}
  , /*decltype(_impl_.fbreakoutdur_)*/0
  , /*decltype(_impl_.fbreakouttorq_)*/0
  , /*decltype(_impl_.dwbreakoutpnt_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TorqueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TorqueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TorqueDefaultTypeInternal() {}
  union {
    Torque _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TorqueDefaultTypeInternal _Torque_default_instance_;
}  // namespace TorqData
static ::_pb::Metadata file_level_metadata_DrillData_2eproto[2];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_DrillData_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_DrillData_2eproto = nullptr;

const uint32_t TableStruct_DrillData_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strvalue_),
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.coltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwseqno_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwquality_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxtorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.ftorque_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.tshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwtotalplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwdelplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwcolinter_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.llcoltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwver_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.btoolbuck_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strmemo_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strremark_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.bbreakout_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwtorqunit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxlimit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrol_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fopttorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fuppercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrolcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxrpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcut_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpmadj_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmulti_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmakeupdur_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwmakeuppnt_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.breakouttime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwbreakoutpnt_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fbreakoutdur_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fbreakouttorq_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::TorqData::ShowInfo)},
  { 8, -1, -1, sizeof(::TorqData::Torque)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TorqData::_ShowInfo_default_instance_._instance,
  &::TorqData::_Torque_default_instance_._instance,
};

const char descriptor_table_protodef_DrillData_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017DrillData.proto\022\010TorqData\"-\n\010ShowInfo\022"
  "\020\n\010strValue\030\002 \001(\014\022\017\n\007strName\030\003 \001(\014\"\275\005\n\006T"
  "orque\022\017\n\007coltime\030\001 \001(\006\022\017\n\007dwSeqNo\030\002 \001(\005\022"
  "\021\n\tdwQuality\030\003 \001(\005\022\020\n\010fMaxTorq\030\005 \001(\001\022\023\n\007"
  "fTorque\030\006 \003(\001B\002\020\001\022\020\n\004fRpm\030\007 \003(\001B\002\020\001\022!\n\005t"
  "Show\030\010 \003(\0132\022.TorqData.ShowInfo\022\023\n\013dwTota"
  "lPlus\030\013 \001(\005\022\025\n\tdwDelPlus\030\r \003(\005B\002\020\001\022\022\n\ndw"
  "ColInter\030\016 \001(\005\022\021\n\tllColTime\030\017 \001(\014\022\r\n\005dwV"
  "er\030\020 \001(\005\022\021\n\tbToolBuck\030\025 \001(\010\022\017\n\007strMemo\030\026"
  " \001(\014\022\021\n\tstrRemark\030\027 \001(\014\022\021\n\tbBreakOut\030\031 \001"
  "(\010\022\022\n\ndwTorqUnit\030\033 \001(\005\022\021\n\tfMaxLimit\030\037 \001("
  "\001\022\020\n\010fControl\030! \001(\001\022\r\n\005fShow\030$ \001(\001\022\020\n\010fO"
  "ptTorq\030( \001(\001\022\017\n\007fMaxCir\030) \001(\001\022\021\n\tfUpperC"
  "ir\030* \001(\001\022\023\n\013fControlCir\030+ \001(\001\022\021\n\tfLowerC"
  "ir\030, \001(\001\022\r\n\005fPlus\0303 \001(\001\022\017\n\007fMaxRPM\0304 \001(\001"
  "\022\014\n\004fCut\0305 \001(\001\022\017\n\007fRpmAdj\0306 \001(\001\022\016\n\006fMult"
  "i\0307 \001(\001\022\022\n\nfMakeupDur\030I \001(\001\022\023\n\013dwMakeupP"
  "nt\030J \001(\005\022\024\n\014breakouttime\030Q \001(\006\022\025\n\rdwBrea"
  "koutPnt\030S \001(\005\022\024\n\014fBreakoutDur\030R \001(\001\022\025\n\rf"
  "BreakoutTorq\030T \001(\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_DrillData_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_DrillData_2eproto = {
    false, false, 786, descriptor_table_protodef_DrillData_2eproto,
    "DrillData.proto",
    &descriptor_table_DrillData_2eproto_once, nullptr, 0, 2,
    schemas, file_default_instances, TableStruct_DrillData_2eproto::offsets,
    file_level_metadata_DrillData_2eproto, file_level_enum_descriptors_DrillData_2eproto,
    file_level_service_descriptors_DrillData_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_DrillData_2eproto_getter() {
  return &descriptor_table_DrillData_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_DrillData_2eproto(&descriptor_table_DrillData_2eproto);
namespace TorqData {

// ===================================================================

class ShowInfo::_Internal {
 public:
};

ShowInfo::ShowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.ShowInfo)
}
ShowInfo::ShowInfo(const ShowInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShowInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strvalue().empty()) {
    _this->_impl_.strvalue_.Set(from._internal_strvalue(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strname().empty()) {
    _this->_impl_.strname_.Set(from._internal_strname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TorqData.ShowInfo)
}

inline void ShowInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShowInfo::~ShowInfo() {
  // @@protoc_insertion_point(destructor:TorqData.ShowInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.strvalue_.Destroy();
  _impl_.strname_.Destroy();
}

void ShowInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShowInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.strvalue_.ClearToEmpty();
  _impl_.strname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShowInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes strValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_strvalue();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_strname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_strvalue(), target);
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_strname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.ShowInfo)
  return target;
}

size_t ShowInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.ShowInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strvalue());
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShowInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShowInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShowInfo::GetClassData() const { return &_class_data_; }


void ShowInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShowInfo*>(&to_msg);
  auto& from = static_cast<const ShowInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.ShowInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_strvalue().empty()) {
    _this->_internal_set_strvalue(from._internal_strvalue());
  }
  if (!from._internal_strname().empty()) {
    _this->_internal_set_strname(from._internal_strname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShowInfo::CopyFrom(const ShowInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.ShowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfo::IsInitialized() const {
  return true;
}

void ShowInfo::InternalSwap(ShowInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strvalue_, lhs_arena,
      &other->_impl_.strvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strname_, lhs_arena,
      &other->_impl_.strname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ShowInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DrillData_2eproto_getter, &descriptor_table_DrillData_2eproto_once,
      file_level_metadata_DrillData_2eproto[0]);
}

// ===================================================================

class Torque::_Internal {
 public:
};

Torque::Torque(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.Torque)
}
Torque::Torque(const Torque& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Torque* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){from._impl_.ftorque_}
    , decltype(_impl_.frpm_){from._impl_.frpm_}
    , decltype(_impl_.tshow_){from._impl_.tshow_}
    , decltype(_impl_.dwdelplus_){from._impl_.dwdelplus_}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.llcoltime_){}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.coltime_){}
    , decltype(_impl_.dwseqno_){}
    , decltype(_impl_.dwquality_){}
    , decltype(_impl_.fmaxtorq_){}
    , decltype(_impl_.dwtotalplus_){}
    , decltype(_impl_.dwcolinter_){}
    , decltype(_impl_.dwver_){}
    , decltype(_impl_.btoolbuck_){}
    , decltype(_impl_.bbreakout_){}
    , decltype(_impl_.fmaxlimit_){}
    , decltype(_impl_.fcontrol_){}
    , decltype(_impl_.fshow_){}
    , decltype(_impl_.fopttorq_){}
    , decltype(_impl_.fmaxcir_){}
    , decltype(_impl_.fuppercir_){}
    , decltype(_impl_.fcontrolcir_){}
    , decltype(_impl_.flowercir_){}
    , decltype(_impl_.dwtorqunit_){}
    , decltype(_impl_.dwmakeuppnt_){}
    , decltype(_impl_.fplus_){}
    , decltype(_impl_.fmaxrpm_){}
    , decltype(_impl_.fcut_){}
    , decltype(_impl_.frpmadj_){}
    , decltype(_impl_.fmulti_){}
    , decltype(_impl_.fmakeupdur_){}
    , decltype(_impl_.breakouttime_){}
    , decltype(_impl_.fbreakoutdur_){}
    , decltype(_impl_.fbreakouttorq_){}
    , decltype(_impl_.dwbreakoutpnt_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.llcoltime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.llcoltime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_llcoltime().empty()) {
    _this->_impl_.llcoltime_.Set(from._internal_llcoltime(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strmemo().empty()) {
    _this->_impl_.strmemo_.Set(from._internal_strmemo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strremark().empty()) {
    _this->_impl_.strremark_.Set(from._internal_strremark(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.coltime_, &from._impl_.coltime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dwbreakoutpnt_) -
    reinterpret_cast<char*>(&_impl_.coltime_)) + sizeof(_impl_.dwbreakoutpnt_));
  // @@protoc_insertion_point(copy_constructor:TorqData.Torque)
}

inline void Torque::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){arena}
    , decltype(_impl_.frpm_){arena}
    , decltype(_impl_.tshow_){arena}
    , decltype(_impl_.dwdelplus_){arena}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.llcoltime_){}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.coltime_){uint64_t{0u}}
    , decltype(_impl_.dwseqno_){0}
    , decltype(_impl_.dwquality_){0}
    , decltype(_impl_.fmaxtorq_){0}
    , decltype(_impl_.dwtotalplus_){0}
    , decltype(_impl_.dwcolinter_){0}
    , decltype(_impl_.dwver_){0}
    , decltype(_impl_.btoolbuck_){false}
    , decltype(_impl_.bbreakout_){false}
    , decltype(_impl_.fmaxlimit_){0}
    , decltype(_impl_.fcontrol_){0}
    , decltype(_impl_.fshow_){0}
    , decltype(_impl_.fopttorq_){0}
    , decltype(_impl_.fmaxcir_){0}
    , decltype(_impl_.fuppercir_){0}
    , decltype(_impl_.fcontrolcir_){0}
    , decltype(_impl_.flowercir_){0}
    , decltype(_impl_.dwtorqunit_){0}
    , decltype(_impl_.dwmakeuppnt_){0}
    , decltype(_impl_.fplus_){0}
    , decltype(_impl_.fmaxrpm_){0}
    , decltype(_impl_.fcut_){0}
    , decltype(_impl_.frpmadj_){0}
    , decltype(_impl_.fmulti_){0}
    , decltype(_impl_.fmakeupdur_){0}
    , decltype(_impl_.breakouttime_){uint64_t{0u}}
    , decltype(_impl_.fbreakoutdur_){0}
    , decltype(_impl_.fbreakouttorq_){0}
    , decltype(_impl_.dwbreakoutpnt_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.llcoltime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.llcoltime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Torque::~Torque() {
  // @@protoc_insertion_point(destructor:TorqData.Torque)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Torque::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ftorque_.~RepeatedField();
  _impl_.frpm_.~RepeatedField();
  _impl_.tshow_.~RepeatedPtrField();
  _impl_.dwdelplus_.~RepeatedField();
  _impl_.llcoltime_.Destroy();
  _impl_.strmemo_.Destroy();
  _impl_.strremark_.Destroy();
}

void Torque::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Torque::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ftorque_.Clear();
  _impl_.frpm_.Clear();
  _impl_.tshow_.Clear();
  _impl_.dwdelplus_.Clear();
  _impl_.llcoltime_.ClearToEmpty();
  _impl_.strmemo_.ClearToEmpty();
  _impl_.strremark_.ClearToEmpty();
  ::memset(&_impl_.coltime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dwbreakoutpnt_) -
      reinterpret_cast<char*>(&_impl_.coltime_)) + sizeof(_impl_.dwbreakoutpnt_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Torque::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 coltime = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.coltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 dwSeqNo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.dwseqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwQuality = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dwquality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMaxTorq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.fmaxtorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double fTorque = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_ftorque(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 49) {
          _internal_add_ftorque(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double fRpm = 7 [packed = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_frpm(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 57) {
          _internal_add_frpm(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .TorqData.ShowInfo tShow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tshow(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 dwTotalPlus = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.dwtotalplus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dwDelPlus = 13 [packed = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dwdelplus(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 104) {
          _internal_add_dwdelplus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwColInter = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.dwcolinter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes llColTime = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_llcoltime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwVer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.dwver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bToolBuck = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.btoolbuck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strMemo = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_strmemo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strRemark = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_strremark();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bBreakOut = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.bbreakout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwTorqUnit = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.dwtorqunit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMaxLimit = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          _impl_.fmaxlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControl = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.fcontrol_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fShow = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.fshow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fOptTorq = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.fopttorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxCir = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.fmaxcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperCir = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.fuppercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControlCir = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.fcontrolcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerCir = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.flowercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fPlus = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _impl_.fplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxRPM = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.fmaxrpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fCut = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _impl_.fcut_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fRpmAdj = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _impl_.frpmadj_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMulti = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _impl_.fmulti_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMakeupDur = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.fmakeupdur_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 dwMakeupPnt = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.dwmakeuppnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 breakouttime = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _impl_.breakouttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // double fBreakoutDur = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 145)) {
          _impl_.fbreakoutdur_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 dwBreakoutPnt = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.dwbreakoutpnt_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fBreakoutTorq = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.fbreakouttorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Torque::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 coltime = 1;
  if (this->_internal_coltime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_coltime(), target);
  }

  // int32 dwSeqNo = 2;
  if (this->_internal_dwseqno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dwseqno(), target);
  }

  // int32 dwQuality = 3;
  if (this->_internal_dwquality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_dwquality(), target);
  }

  // double fMaxTorq = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = this->_internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_fmaxtorq(), target);
  }

  // repeated double fTorque = 6 [packed = true];
  if (this->_internal_ftorque_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_ftorque(), target);
  }

  // repeated double fRpm = 7 [packed = true];
  if (this->_internal_frpm_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_frpm(), target);
  }

  // repeated .TorqData.ShowInfo tShow = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tshow_size()); i < n; i++) {
    const auto& repfield = this->_internal_tshow(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 dwTotalPlus = 11;
  if (this->_internal_dwtotalplus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_dwtotalplus(), target);
  }

  // repeated int32 dwDelPlus = 13 [packed = true];
  {
    int byte_size = _impl_._dwdelplus_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          13, _internal_dwdelplus(), byte_size, target);
    }
  }

  // int32 dwColInter = 14;
  if (this->_internal_dwcolinter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_dwcolinter(), target);
  }

  // bytes llColTime = 15;
  if (!this->_internal_llcoltime().empty()) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_llcoltime(), target);
  }

  // int32 dwVer = 16;
  if (this->_internal_dwver() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_dwver(), target);
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_btoolbuck(), target);
  }

  // bytes strMemo = 22;
  if (!this->_internal_strmemo().empty()) {
    target = stream->WriteBytesMaybeAliased(
        22, this->_internal_strmemo(), target);
  }

  // bytes strRemark = 23;
  if (!this->_internal_strremark().empty()) {
    target = stream->WriteBytesMaybeAliased(
        23, this->_internal_strremark(), target);
  }

  // bool bBreakOut = 25;
  if (this->_internal_bbreakout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_bbreakout(), target);
  }

  // int32 dwTorqUnit = 27;
  if (this->_internal_dwtorqunit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(27, this->_internal_dwtorqunit(), target);
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(31, this->_internal_fmaxlimit(), target);
  }

  // double fControl = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_fcontrol(), target);
  }

  // double fShow = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(36, this->_internal_fshow(), target);
  }

  // double fOptTorq = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(40, this->_internal_fopttorq(), target);
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(41, this->_internal_fmaxcir(), target);
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(42, this->_internal_fuppercir(), target);
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(43, this->_internal_fcontrolcir(), target);
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(44, this->_internal_flowercir(), target);
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(51, this->_internal_fplus(), target);
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(52, this->_internal_fmaxrpm(), target);
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(53, this->_internal_fcut(), target);
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(54, this->_internal_frpmadj(), target);
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(55, this->_internal_fmulti(), target);
  }

  // double fMakeupDur = 73;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = this->_internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(73, this->_internal_fmakeupdur(), target);
  }

  // int32 dwMakeupPnt = 74;
  if (this->_internal_dwmakeuppnt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(74, this->_internal_dwmakeuppnt(), target);
  }

  // fixed64 breakouttime = 81;
  if (this->_internal_breakouttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(81, this->_internal_breakouttime(), target);
  }

  // double fBreakoutDur = 82;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakoutdur = this->_internal_fbreakoutdur();
  uint64_t raw_fbreakoutdur;
  memcpy(&raw_fbreakoutdur, &tmp_fbreakoutdur, sizeof(tmp_fbreakoutdur));
  if (raw_fbreakoutdur != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(82, this->_internal_fbreakoutdur(), target);
  }

  // int32 dwBreakoutPnt = 83;
  if (this->_internal_dwbreakoutpnt() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(83, this->_internal_dwbreakoutpnt(), target);
  }

  // double fBreakoutTorq = 84;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakouttorq = this->_internal_fbreakouttorq();
  uint64_t raw_fbreakouttorq;
  memcpy(&raw_fbreakouttorq, &tmp_fbreakouttorq, sizeof(tmp_fbreakouttorq));
  if (raw_fbreakouttorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(84, this->_internal_fbreakouttorq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.Torque)
  return target;
}

size_t Torque::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.Torque)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double fTorque = 6 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ftorque_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double fRpm = 7 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_frpm_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .TorqData.ShowInfo tShow = 8;
  total_size += 1UL * this->_internal_tshow_size();
  for (const auto& msg : this->_impl_.tshow_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 dwDelPlus = 13 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.dwdelplus_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dwdelplus_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bytes llColTime = 15;
  if (!this->_internal_llcoltime().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_llcoltime());
  }

  // bytes strMemo = 22;
  if (!this->_internal_strmemo().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strmemo());
  }

  // bytes strRemark = 23;
  if (!this->_internal_strremark().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strremark());
  }

  // fixed64 coltime = 1;
  if (this->_internal_coltime() != 0) {
    total_size += 1 + 8;
  }

  // int32 dwSeqNo = 2;
  if (this->_internal_dwseqno() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwseqno());
  }

  // int32 dwQuality = 3;
  if (this->_internal_dwquality() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwquality());
  }

  // double fMaxTorq = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = this->_internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    total_size += 1 + 8;
  }

  // int32 dwTotalPlus = 11;
  if (this->_internal_dwtotalplus() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwtotalplus());
  }

  // int32 dwColInter = 14;
  if (this->_internal_dwcolinter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwcolinter());
  }

  // int32 dwVer = 16;
  if (this->_internal_dwver() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwver());
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    total_size += 2 + 1;
  }

  // bool bBreakOut = 25;
  if (this->_internal_bbreakout() != 0) {
    total_size += 2 + 1;
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    total_size += 2 + 8;
  }

  // double fControl = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    total_size += 2 + 8;
  }

  // double fShow = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    total_size += 2 + 8;
  }

  // double fOptTorq = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    total_size += 2 + 8;
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    total_size += 2 + 8;
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    total_size += 2 + 8;
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    total_size += 2 + 8;
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    total_size += 2 + 8;
  }

  // int32 dwTorqUnit = 27;
  if (this->_internal_dwtorqunit() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwtorqunit());
  }

  // int32 dwMakeupPnt = 74;
  if (this->_internal_dwmakeuppnt() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwmakeuppnt());
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    total_size += 2 + 8;
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    total_size += 2 + 8;
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    total_size += 2 + 8;
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    total_size += 2 + 8;
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    total_size += 2 + 8;
  }

  // double fMakeupDur = 73;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = this->_internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    total_size += 2 + 8;
  }

  // fixed64 breakouttime = 81;
  if (this->_internal_breakouttime() != 0) {
    total_size += 2 + 8;
  }

  // double fBreakoutDur = 82;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakoutdur = this->_internal_fbreakoutdur();
  uint64_t raw_fbreakoutdur;
  memcpy(&raw_fbreakoutdur, &tmp_fbreakoutdur, sizeof(tmp_fbreakoutdur));
  if (raw_fbreakoutdur != 0) {
    total_size += 2 + 8;
  }

  // double fBreakoutTorq = 84;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakouttorq = this->_internal_fbreakouttorq();
  uint64_t raw_fbreakouttorq;
  memcpy(&raw_fbreakouttorq, &tmp_fbreakouttorq, sizeof(tmp_fbreakouttorq));
  if (raw_fbreakouttorq != 0) {
    total_size += 2 + 8;
  }

  // int32 dwBreakoutPnt = 83;
  if (this->_internal_dwbreakoutpnt() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwbreakoutpnt());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Torque::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Torque::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Torque::GetClassData() const { return &_class_data_; }


void Torque::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Torque*>(&to_msg);
  auto& from = static_cast<const Torque&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.Torque)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ftorque_.MergeFrom(from._impl_.ftorque_);
  _this->_impl_.frpm_.MergeFrom(from._impl_.frpm_);
  _this->_impl_.tshow_.MergeFrom(from._impl_.tshow_);
  _this->_impl_.dwdelplus_.MergeFrom(from._impl_.dwdelplus_);
  if (!from._internal_llcoltime().empty()) {
    _this->_internal_set_llcoltime(from._internal_llcoltime());
  }
  if (!from._internal_strmemo().empty()) {
    _this->_internal_set_strmemo(from._internal_strmemo());
  }
  if (!from._internal_strremark().empty()) {
    _this->_internal_set_strremark(from._internal_strremark());
  }
  if (from._internal_coltime() != 0) {
    _this->_internal_set_coltime(from._internal_coltime());
  }
  if (from._internal_dwseqno() != 0) {
    _this->_internal_set_dwseqno(from._internal_dwseqno());
  }
  if (from._internal_dwquality() != 0) {
    _this->_internal_set_dwquality(from._internal_dwquality());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = from._internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    _this->_internal_set_fmaxtorq(from._internal_fmaxtorq());
  }
  if (from._internal_dwtotalplus() != 0) {
    _this->_internal_set_dwtotalplus(from._internal_dwtotalplus());
  }
  if (from._internal_dwcolinter() != 0) {
    _this->_internal_set_dwcolinter(from._internal_dwcolinter());
  }
  if (from._internal_dwver() != 0) {
    _this->_internal_set_dwver(from._internal_dwver());
  }
  if (from._internal_btoolbuck() != 0) {
    _this->_internal_set_btoolbuck(from._internal_btoolbuck());
  }
  if (from._internal_bbreakout() != 0) {
    _this->_internal_set_bbreakout(from._internal_bbreakout());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = from._internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    _this->_internal_set_fmaxlimit(from._internal_fmaxlimit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = from._internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    _this->_internal_set_fcontrol(from._internal_fcontrol());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = from._internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    _this->_internal_set_fshow(from._internal_fshow());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = from._internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    _this->_internal_set_fopttorq(from._internal_fopttorq());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = from._internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    _this->_internal_set_fmaxcir(from._internal_fmaxcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = from._internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    _this->_internal_set_fuppercir(from._internal_fuppercir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = from._internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    _this->_internal_set_fcontrolcir(from._internal_fcontrolcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = from._internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    _this->_internal_set_flowercir(from._internal_flowercir());
  }
  if (from._internal_dwtorqunit() != 0) {
    _this->_internal_set_dwtorqunit(from._internal_dwtorqunit());
  }
  if (from._internal_dwmakeuppnt() != 0) {
    _this->_internal_set_dwmakeuppnt(from._internal_dwmakeuppnt());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = from._internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    _this->_internal_set_fplus(from._internal_fplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = from._internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    _this->_internal_set_fmaxrpm(from._internal_fmaxrpm());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = from._internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    _this->_internal_set_fcut(from._internal_fcut());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = from._internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    _this->_internal_set_frpmadj(from._internal_frpmadj());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = from._internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    _this->_internal_set_fmulti(from._internal_fmulti());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = from._internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    _this->_internal_set_fmakeupdur(from._internal_fmakeupdur());
  }
  if (from._internal_breakouttime() != 0) {
    _this->_internal_set_breakouttime(from._internal_breakouttime());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakoutdur = from._internal_fbreakoutdur();
  uint64_t raw_fbreakoutdur;
  memcpy(&raw_fbreakoutdur, &tmp_fbreakoutdur, sizeof(tmp_fbreakoutdur));
  if (raw_fbreakoutdur != 0) {
    _this->_internal_set_fbreakoutdur(from._internal_fbreakoutdur());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbreakouttorq = from._internal_fbreakouttorq();
  uint64_t raw_fbreakouttorq;
  memcpy(&raw_fbreakouttorq, &tmp_fbreakouttorq, sizeof(tmp_fbreakouttorq));
  if (raw_fbreakouttorq != 0) {
    _this->_internal_set_fbreakouttorq(from._internal_fbreakouttorq());
  }
  if (from._internal_dwbreakoutpnt() != 0) {
    _this->_internal_set_dwbreakoutpnt(from._internal_dwbreakoutpnt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Torque::CopyFrom(const Torque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.Torque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Torque::IsInitialized() const {
  return true;
}

void Torque::InternalSwap(Torque* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ftorque_.InternalSwap(&other->_impl_.ftorque_);
  _impl_.frpm_.InternalSwap(&other->_impl_.frpm_);
  _impl_.tshow_.InternalSwap(&other->_impl_.tshow_);
  _impl_.dwdelplus_.InternalSwap(&other->_impl_.dwdelplus_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.llcoltime_, lhs_arena,
      &other->_impl_.llcoltime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strmemo_, lhs_arena,
      &other->_impl_.strmemo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strremark_, lhs_arena,
      &other->_impl_.strremark_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Torque, _impl_.dwbreakoutpnt_)
      + sizeof(Torque::_impl_.dwbreakoutpnt_)
      - PROTOBUF_FIELD_OFFSET(Torque, _impl_.coltime_)>(
          reinterpret_cast<char*>(&_impl_.coltime_),
          reinterpret_cast<char*>(&other->_impl_.coltime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Torque::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DrillData_2eproto_getter, &descriptor_table_DrillData_2eproto_once,
      file_level_metadata_DrillData_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TorqData
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TorqData::ShowInfo*
Arena::CreateMaybeMessage< ::TorqData::ShowInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::ShowInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::TorqData::Torque*
Arena::CreateMaybeMessage< ::TorqData::Torque >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::Torque >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
