// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TorqData.proto

#include "TorqData.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TorqData {
PROTOBUF_CONSTEXPR ShowInfo::ShowInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.strvalue_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShowInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowInfoDefaultTypeInternal() {}
  union {
    ShowInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowInfoDefaultTypeInternal _ShowInfo_default_instance_;
PROTOBUF_CONSTEXPR Torque::Torque(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ftorque_)*/{}
  , /*decltype(_impl_.frpm_)*/{}
  , /*decltype(_impl_.tshow_)*/{}
  , /*decltype(_impl_.dwdelplus_)*/{}
  , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
  , /*decltype(_impl_.llcoltime_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strmemo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strremark_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.coltime_)*/uint64_t{0u}
  , /*decltype(_impl_.dwseqno_)*/0
  , /*decltype(_impl_.dwquality_)*/0
  , /*decltype(_impl_.fmaxtorq_)*/0
  , /*decltype(_impl_.dwippos_)*/0
  , /*decltype(_impl_.dwiptorq_)*/0
  , /*decltype(_impl_.begintime_)*/uint64_t{0u}
  , /*decltype(_impl_.dwtotalplus_)*/0
  , /*decltype(_impl_.dwipplus_)*/0
  , /*decltype(_impl_.dwcolinter_)*/0
  , /*decltype(_impl_.dwver_)*/0
  , /*decltype(_impl_.btoolbuck_)*/false
  , /*decltype(_impl_.bncheckip_)*/false
  , /*decltype(_impl_.bshackle_)*/false
  , /*decltype(_impl_.btimeline_)*/false
  , /*decltype(_impl_.dwtorqunit_)*/0
  , /*decltype(_impl_.fmaxlimit_)*/0
  , /*decltype(_impl_.fupperlimit_)*/0
  , /*decltype(_impl_.fcontrol_)*/0
  , /*decltype(_impl_.flowerlimit_)*/0
  , /*decltype(_impl_.fspeeddown_)*/0
  , /*decltype(_impl_.fshow_)*/0
  , /*decltype(_impl_.fbear_)*/0
  , /*decltype(_impl_.fuppertai_)*/0
  , /*decltype(_impl_.flowertai_)*/0
  , /*decltype(_impl_.fopttorq_)*/0
  , /*decltype(_impl_.fmaxcir_)*/0
  , /*decltype(_impl_.fuppercir_)*/0
  , /*decltype(_impl_.fcontrolcir_)*/0
  , /*decltype(_impl_.flowercir_)*/0
  , /*decltype(_impl_.fmaxtime_)*/0
  , /*decltype(_impl_.fuppertime_)*/0
  , /*decltype(_impl_.fcontroltime_)*/0
  , /*decltype(_impl_.flowertime_)*/0
  , /*decltype(_impl_.fplus_)*/0
  , /*decltype(_impl_.fmaxrpm_)*/0
  , /*decltype(_impl_.fcut_)*/0
  , /*decltype(_impl_.frpmadj_)*/0
  , /*decltype(_impl_.fmulti_)*/0
  , /*decltype(_impl_.fminshlslope_)*/0
  , /*decltype(_impl_.fmaxdeltacir_)*/0
  , /*decltype(_impl_.fmindeltacir_)*/0
  , /*decltype(_impl_.fmakeupdur_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TorqueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TorqueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TorqueDefaultTypeInternal() {}
  union {
    Torque _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TorqueDefaultTypeInternal _Torque_default_instance_;
}  // namespace TorqData
static ::_pb::Metadata file_level_metadata_TorqData_2eproto[2];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_TorqData_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_TorqData_2eproto = nullptr;

const uint32_t TableStruct_TorqData_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strvalue_),
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.coltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwseqno_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwquality_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwippos_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxtorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.ftorque_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.tshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.begintime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwiptorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwtotalplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwipplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwdelplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwcolinter_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.llcoltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwver_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.btoolbuck_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strmemo_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strremark_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.bncheckip_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.bshackle_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.btimeline_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwtorqunit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxlimit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fupperlimit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrol_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowerlimit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fspeeddown_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fbear_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fuppertai_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowertai_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fopttorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fuppercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrolcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxtime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fuppertime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontroltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowertime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxrpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcut_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpmadj_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmulti_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fminshlslope_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxdeltacir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmindeltacir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmakeupdur_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::TorqData::ShowInfo)},
  { 8, -1, -1, sizeof(::TorqData::Torque)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TorqData::_ShowInfo_default_instance_._instance,
  &::TorqData::_Torque_default_instance_._instance,
};

const char descriptor_table_protodef_TorqData_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016TorqData.proto\022\010TorqData\"-\n\010ShowInfo\022\020"
  "\n\010strValue\030\002 \001(\014\022\017\n\007strName\030\003 \001(\014\"\300\007\n\006To"
  "rque\022\017\n\007coltime\030\001 \001(\006\022\017\n\007dwSeqNo\030\002 \001(\005\022\021"
  "\n\tdwQuality\030\003 \001(\005\022\017\n\007dwIPPos\030\004 \001(\005\022\020\n\010fM"
  "axTorq\030\005 \001(\001\022\023\n\007fTorque\030\006 \003(\001B\002\020\001\022\020\n\004fRp"
  "m\030\007 \003(\001B\002\020\001\022!\n\005tShow\030\010 \003(\0132\022.TorqData.Sh"
  "owInfo\022\021\n\tbegintime\030\t \001(\006\022\020\n\010dwIPTorq\030\n "
  "\001(\005\022\023\n\013dwTotalPlus\030\013 \001(\005\022\020\n\010dwIPPlus\030\014 \001"
  "(\005\022\025\n\tdwDelPlus\030\r \003(\005B\002\020\001\022\022\n\ndwColInter\030"
  "\016 \001(\005\022\021\n\tllColTime\030\017 \001(\014\022\r\n\005dwVer\030\020 \001(\005\022"
  "\021\n\tbToolBuck\030\025 \001(\010\022\017\n\007strMemo\030\026 \001(\014\022\021\n\ts"
  "trRemark\030\027 \001(\014\022\021\n\tbNCheckIP\030\030 \001(\010\022\020\n\010bSh"
  "ackle\030\031 \001(\010\022\021\n\tbTimeLine\030\032 \001(\010\022\022\n\ndwTorq"
  "Unit\030\033 \001(\005\022\021\n\tfMaxLimit\030\037 \001(\001\022\023\n\013fUpperL"
  "imit\030  \001(\001\022\020\n\010fControl\030! \001(\001\022\023\n\013fLowerLi"
  "mit\030\" \001(\001\022\022\n\nfSpeedDown\030# \001(\001\022\r\n\005fShow\030$"
  " \001(\001\022\r\n\005fBear\030% \001(\001\022\021\n\tfUpperTai\030& \001(\001\022\021"
  "\n\tfLowerTai\030\' \001(\001\022\020\n\010fOptTorq\030( \001(\001\022\017\n\007f"
  "MaxCir\030) \001(\001\022\021\n\tfUpperCir\030* \001(\001\022\023\n\013fCont"
  "rolCir\030+ \001(\001\022\021\n\tfLowerCir\030, \001(\001\022\020\n\010fMaxT"
  "ime\030- \001(\001\022\022\n\nfUpperTime\030. \001(\001\022\024\n\014fContro"
  "lTime\030/ \001(\001\022\022\n\nfLowerTime\0300 \001(\001\022\r\n\005fPlus"
  "\0303 \001(\001\022\017\n\007fMaxRPM\0304 \001(\001\022\014\n\004fCut\0305 \001(\001\022\017\n"
  "\007fRpmAdj\0306 \001(\001\022\016\n\006fMulti\0307 \001(\001\022\024\n\014fMinSh"
  "lSlope\030F \001(\001\022\024\n\014fMaxDeltaCir\030G \001(\001\022\024\n\014fM"
  "inDeltaCir\030H \001(\001\022\022\n\nfMakeupDur\030I \001(\001b\006pr"
  "oto3"
  ;
static ::_pbi::once_flag descriptor_table_TorqData_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_TorqData_2eproto = {
    false, false, 1044, descriptor_table_protodef_TorqData_2eproto,
    "TorqData.proto",
    &descriptor_table_TorqData_2eproto_once, nullptr, 0, 2,
    schemas, file_default_instances, TableStruct_TorqData_2eproto::offsets,
    file_level_metadata_TorqData_2eproto, file_level_enum_descriptors_TorqData_2eproto,
    file_level_service_descriptors_TorqData_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_TorqData_2eproto_getter() {
  return &descriptor_table_TorqData_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_TorqData_2eproto(&descriptor_table_TorqData_2eproto);
namespace TorqData {

// ===================================================================

class ShowInfo::_Internal {
 public:
};

ShowInfo::ShowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.ShowInfo)
}
ShowInfo::ShowInfo(const ShowInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShowInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strvalue().empty()) {
    _this->_impl_.strvalue_.Set(from._internal_strvalue(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strname().empty()) {
    _this->_impl_.strname_.Set(from._internal_strname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TorqData.ShowInfo)
}

inline void ShowInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShowInfo::~ShowInfo() {
  // @@protoc_insertion_point(destructor:TorqData.ShowInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.strvalue_.Destroy();
  _impl_.strname_.Destroy();
}

void ShowInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShowInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.strvalue_.ClearToEmpty();
  _impl_.strname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShowInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes strValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_strvalue();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_strname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_strvalue(), target);
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_strname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.ShowInfo)
  return target;
}

size_t ShowInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.ShowInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strvalue());
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShowInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShowInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShowInfo::GetClassData() const { return &_class_data_; }


void ShowInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShowInfo*>(&to_msg);
  auto& from = static_cast<const ShowInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.ShowInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_strvalue().empty()) {
    _this->_internal_set_strvalue(from._internal_strvalue());
  }
  if (!from._internal_strname().empty()) {
    _this->_internal_set_strname(from._internal_strname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShowInfo::CopyFrom(const ShowInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.ShowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfo::IsInitialized() const {
  return true;
}

void ShowInfo::InternalSwap(ShowInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strvalue_, lhs_arena,
      &other->_impl_.strvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strname_, lhs_arena,
      &other->_impl_.strname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ShowInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TorqData_2eproto_getter, &descriptor_table_TorqData_2eproto_once,
      file_level_metadata_TorqData_2eproto[0]);
}

// ===================================================================

class Torque::_Internal {
 public:
};

Torque::Torque(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.Torque)
}
Torque::Torque(const Torque& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Torque* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){from._impl_.ftorque_}
    , decltype(_impl_.frpm_){from._impl_.frpm_}
    , decltype(_impl_.tshow_){from._impl_.tshow_}
    , decltype(_impl_.dwdelplus_){from._impl_.dwdelplus_}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.llcoltime_){}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.coltime_){}
    , decltype(_impl_.dwseqno_){}
    , decltype(_impl_.dwquality_){}
    , decltype(_impl_.fmaxtorq_){}
    , decltype(_impl_.dwippos_){}
    , decltype(_impl_.dwiptorq_){}
    , decltype(_impl_.begintime_){}
    , decltype(_impl_.dwtotalplus_){}
    , decltype(_impl_.dwipplus_){}
    , decltype(_impl_.dwcolinter_){}
    , decltype(_impl_.dwver_){}
    , decltype(_impl_.btoolbuck_){}
    , decltype(_impl_.bncheckip_){}
    , decltype(_impl_.bshackle_){}
    , decltype(_impl_.btimeline_){}
    , decltype(_impl_.dwtorqunit_){}
    , decltype(_impl_.fmaxlimit_){}
    , decltype(_impl_.fupperlimit_){}
    , decltype(_impl_.fcontrol_){}
    , decltype(_impl_.flowerlimit_){}
    , decltype(_impl_.fspeeddown_){}
    , decltype(_impl_.fshow_){}
    , decltype(_impl_.fbear_){}
    , decltype(_impl_.fuppertai_){}
    , decltype(_impl_.flowertai_){}
    , decltype(_impl_.fopttorq_){}
    , decltype(_impl_.fmaxcir_){}
    , decltype(_impl_.fuppercir_){}
    , decltype(_impl_.fcontrolcir_){}
    , decltype(_impl_.flowercir_){}
    , decltype(_impl_.fmaxtime_){}
    , decltype(_impl_.fuppertime_){}
    , decltype(_impl_.fcontroltime_){}
    , decltype(_impl_.flowertime_){}
    , decltype(_impl_.fplus_){}
    , decltype(_impl_.fmaxrpm_){}
    , decltype(_impl_.fcut_){}
    , decltype(_impl_.frpmadj_){}
    , decltype(_impl_.fmulti_){}
    , decltype(_impl_.fminshlslope_){}
    , decltype(_impl_.fmaxdeltacir_){}
    , decltype(_impl_.fmindeltacir_){}
    , decltype(_impl_.fmakeupdur_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.llcoltime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.llcoltime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_llcoltime().empty()) {
    _this->_impl_.llcoltime_.Set(from._internal_llcoltime(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strmemo().empty()) {
    _this->_impl_.strmemo_.Set(from._internal_strmemo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strremark().empty()) {
    _this->_impl_.strremark_.Set(from._internal_strremark(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.coltime_, &from._impl_.coltime_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.fmakeupdur_) -
    reinterpret_cast<char*>(&_impl_.coltime_)) + sizeof(_impl_.fmakeupdur_));
  // @@protoc_insertion_point(copy_constructor:TorqData.Torque)
}

inline void Torque::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){arena}
    , decltype(_impl_.frpm_){arena}
    , decltype(_impl_.tshow_){arena}
    , decltype(_impl_.dwdelplus_){arena}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.llcoltime_){}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.coltime_){uint64_t{0u}}
    , decltype(_impl_.dwseqno_){0}
    , decltype(_impl_.dwquality_){0}
    , decltype(_impl_.fmaxtorq_){0}
    , decltype(_impl_.dwippos_){0}
    , decltype(_impl_.dwiptorq_){0}
    , decltype(_impl_.begintime_){uint64_t{0u}}
    , decltype(_impl_.dwtotalplus_){0}
    , decltype(_impl_.dwipplus_){0}
    , decltype(_impl_.dwcolinter_){0}
    , decltype(_impl_.dwver_){0}
    , decltype(_impl_.btoolbuck_){false}
    , decltype(_impl_.bncheckip_){false}
    , decltype(_impl_.bshackle_){false}
    , decltype(_impl_.btimeline_){false}
    , decltype(_impl_.dwtorqunit_){0}
    , decltype(_impl_.fmaxlimit_){0}
    , decltype(_impl_.fupperlimit_){0}
    , decltype(_impl_.fcontrol_){0}
    , decltype(_impl_.flowerlimit_){0}
    , decltype(_impl_.fspeeddown_){0}
    , decltype(_impl_.fshow_){0}
    , decltype(_impl_.fbear_){0}
    , decltype(_impl_.fuppertai_){0}
    , decltype(_impl_.flowertai_){0}
    , decltype(_impl_.fopttorq_){0}
    , decltype(_impl_.fmaxcir_){0}
    , decltype(_impl_.fuppercir_){0}
    , decltype(_impl_.fcontrolcir_){0}
    , decltype(_impl_.flowercir_){0}
    , decltype(_impl_.fmaxtime_){0}
    , decltype(_impl_.fuppertime_){0}
    , decltype(_impl_.fcontroltime_){0}
    , decltype(_impl_.flowertime_){0}
    , decltype(_impl_.fplus_){0}
    , decltype(_impl_.fmaxrpm_){0}
    , decltype(_impl_.fcut_){0}
    , decltype(_impl_.frpmadj_){0}
    , decltype(_impl_.fmulti_){0}
    , decltype(_impl_.fminshlslope_){0}
    , decltype(_impl_.fmaxdeltacir_){0}
    , decltype(_impl_.fmindeltacir_){0}
    , decltype(_impl_.fmakeupdur_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.llcoltime_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.llcoltime_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Torque::~Torque() {
  // @@protoc_insertion_point(destructor:TorqData.Torque)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Torque::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ftorque_.~RepeatedField();
  _impl_.frpm_.~RepeatedField();
  _impl_.tshow_.~RepeatedPtrField();
  _impl_.dwdelplus_.~RepeatedField();
  _impl_.llcoltime_.Destroy();
  _impl_.strmemo_.Destroy();
  _impl_.strremark_.Destroy();
}

void Torque::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Torque::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ftorque_.Clear();
  _impl_.frpm_.Clear();
  _impl_.tshow_.Clear();
  _impl_.dwdelplus_.Clear();
  _impl_.llcoltime_.ClearToEmpty();
  _impl_.strmemo_.ClearToEmpty();
  _impl_.strremark_.ClearToEmpty();
  ::memset(&_impl_.coltime_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.fmakeupdur_) -
      reinterpret_cast<char*>(&_impl_.coltime_)) + sizeof(_impl_.fmakeupdur_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Torque::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // fixed64 coltime = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.coltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 dwSeqNo = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.dwseqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwQuality = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.dwquality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwIPPos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.dwippos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMaxTorq = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.fmaxtorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double fTorque = 6 [packed = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_ftorque(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 49) {
          _internal_add_ftorque(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double fRpm = 7 [packed = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_frpm(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 57) {
          _internal_add_frpm(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated .TorqData.ShowInfo tShow = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tshow(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // fixed64 begintime = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.begintime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 dwIPTorq = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _impl_.dwiptorq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwTotalPlus = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.dwtotalplus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwIPPlus = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.dwipplus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dwDelPlus = 13 [packed = true];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dwdelplus(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 104) {
          _internal_add_dwdelplus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwColInter = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _impl_.dwcolinter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes llColTime = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_llcoltime();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwVer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.dwver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bToolBuck = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.btoolbuck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strMemo = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_strmemo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strRemark = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_strremark();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bNCheckIP = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _impl_.bncheckip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bShackle = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.bshackle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bTimeLine = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.btimeline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwTorqUnit = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _impl_.dwtorqunit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMaxLimit = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          _impl_.fmaxlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperLimit = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          _impl_.fupperlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControl = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.fcontrol_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerLimit = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.flowerlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fSpeedDown = 35;
      case 35:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _impl_.fspeeddown_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fShow = 36;
      case 36:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _impl_.fshow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fBear = 37;
      case 37:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _impl_.fbear_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperTai = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.fuppertai_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerTai = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.flowertai_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fOptTorq = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.fopttorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxCir = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.fmaxcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperCir = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.fuppercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControlCir = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.fcontrolcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerCir = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.flowercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxTime = 45;
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 105)) {
          _impl_.fmaxtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperTime = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 113)) {
          _impl_.fuppertime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControlTime = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 121)) {
          _impl_.fcontroltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerTime = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 129)) {
          _impl_.flowertime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fPlus = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _impl_.fplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxRPM = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.fmaxrpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fCut = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _impl_.fcut_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fRpmAdj = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _impl_.frpmadj_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMulti = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _impl_.fmulti_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMinShlSlope = 70;
      case 70:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _impl_.fminshlslope_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxDeltaCir = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.fmaxdeltacir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMinDeltaCir = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _impl_.fmindeltacir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMakeupDur = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.fmakeupdur_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Torque::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // fixed64 coltime = 1;
  if (this->_internal_coltime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_coltime(), target);
  }

  // int32 dwSeqNo = 2;
  if (this->_internal_dwseqno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_dwseqno(), target);
  }

  // int32 dwQuality = 3;
  if (this->_internal_dwquality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_dwquality(), target);
  }

  // int32 dwIPPos = 4;
  if (this->_internal_dwippos() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dwippos(), target);
  }

  // double fMaxTorq = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = this->_internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_fmaxtorq(), target);
  }

  // repeated double fTorque = 6 [packed = true];
  if (this->_internal_ftorque_size() > 0) {
    target = stream->WriteFixedPacked(6, _internal_ftorque(), target);
  }

  // repeated double fRpm = 7 [packed = true];
  if (this->_internal_frpm_size() > 0) {
    target = stream->WriteFixedPacked(7, _internal_frpm(), target);
  }

  // repeated .TorqData.ShowInfo tShow = 8;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tshow_size()); i < n; i++) {
    const auto& repfield = this->_internal_tshow(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  // fixed64 begintime = 9;
  if (this->_internal_begintime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(9, this->_internal_begintime(), target);
  }

  // int32 dwIPTorq = 10;
  if (this->_internal_dwiptorq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_dwiptorq(), target);
  }

  // int32 dwTotalPlus = 11;
  if (this->_internal_dwtotalplus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_dwtotalplus(), target);
  }

  // int32 dwIPPlus = 12;
  if (this->_internal_dwipplus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_dwipplus(), target);
  }

  // repeated int32 dwDelPlus = 13 [packed = true];
  {
    int byte_size = _impl_._dwdelplus_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          13, _internal_dwdelplus(), byte_size, target);
    }
  }

  // int32 dwColInter = 14;
  if (this->_internal_dwcolinter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_dwcolinter(), target);
  }

  // bytes llColTime = 15;
  if (!this->_internal_llcoltime().empty()) {
    target = stream->WriteBytesMaybeAliased(
        15, this->_internal_llcoltime(), target);
  }

  // int32 dwVer = 16;
  if (this->_internal_dwver() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(16, this->_internal_dwver(), target);
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_btoolbuck(), target);
  }

  // bytes strMemo = 22;
  if (!this->_internal_strmemo().empty()) {
    target = stream->WriteBytesMaybeAliased(
        22, this->_internal_strmemo(), target);
  }

  // bytes strRemark = 23;
  if (!this->_internal_strremark().empty()) {
    target = stream->WriteBytesMaybeAliased(
        23, this->_internal_strremark(), target);
  }

  // bool bNCheckIP = 24;
  if (this->_internal_bncheckip() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_bncheckip(), target);
  }

  // bool bShackle = 25;
  if (this->_internal_bshackle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_bshackle(), target);
  }

  // bool bTimeLine = 26;
  if (this->_internal_btimeline() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_btimeline(), target);
  }

  // int32 dwTorqUnit = 27;
  if (this->_internal_dwtorqunit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(27, this->_internal_dwtorqunit(), target);
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(31, this->_internal_fmaxlimit(), target);
  }

  // double fUpperLimit = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fupperlimit = this->_internal_fupperlimit();
  uint64_t raw_fupperlimit;
  memcpy(&raw_fupperlimit, &tmp_fupperlimit, sizeof(tmp_fupperlimit));
  if (raw_fupperlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(32, this->_internal_fupperlimit(), target);
  }

  // double fControl = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_fcontrol(), target);
  }

  // double fLowerLimit = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowerlimit = this->_internal_flowerlimit();
  uint64_t raw_flowerlimit;
  memcpy(&raw_flowerlimit, &tmp_flowerlimit, sizeof(tmp_flowerlimit));
  if (raw_flowerlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(34, this->_internal_flowerlimit(), target);
  }

  // double fSpeedDown = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fspeeddown = this->_internal_fspeeddown();
  uint64_t raw_fspeeddown;
  memcpy(&raw_fspeeddown, &tmp_fspeeddown, sizeof(tmp_fspeeddown));
  if (raw_fspeeddown != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(35, this->_internal_fspeeddown(), target);
  }

  // double fShow = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(36, this->_internal_fshow(), target);
  }

  // double fBear = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbear = this->_internal_fbear();
  uint64_t raw_fbear;
  memcpy(&raw_fbear, &tmp_fbear, sizeof(tmp_fbear));
  if (raw_fbear != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(37, this->_internal_fbear(), target);
  }

  // double fUpperTai = 38;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertai = this->_internal_fuppertai();
  uint64_t raw_fuppertai;
  memcpy(&raw_fuppertai, &tmp_fuppertai, sizeof(tmp_fuppertai));
  if (raw_fuppertai != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(38, this->_internal_fuppertai(), target);
  }

  // double fLowerTai = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertai = this->_internal_flowertai();
  uint64_t raw_flowertai;
  memcpy(&raw_flowertai, &tmp_flowertai, sizeof(tmp_flowertai));
  if (raw_flowertai != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(39, this->_internal_flowertai(), target);
  }

  // double fOptTorq = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(40, this->_internal_fopttorq(), target);
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(41, this->_internal_fmaxcir(), target);
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(42, this->_internal_fuppercir(), target);
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(43, this->_internal_fcontrolcir(), target);
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(44, this->_internal_flowercir(), target);
  }

  // double fMaxTime = 45;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtime = this->_internal_fmaxtime();
  uint64_t raw_fmaxtime;
  memcpy(&raw_fmaxtime, &tmp_fmaxtime, sizeof(tmp_fmaxtime));
  if (raw_fmaxtime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(45, this->_internal_fmaxtime(), target);
  }

  // double fUpperTime = 46;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertime = this->_internal_fuppertime();
  uint64_t raw_fuppertime;
  memcpy(&raw_fuppertime, &tmp_fuppertime, sizeof(tmp_fuppertime));
  if (raw_fuppertime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(46, this->_internal_fuppertime(), target);
  }

  // double fControlTime = 47;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontroltime = this->_internal_fcontroltime();
  uint64_t raw_fcontroltime;
  memcpy(&raw_fcontroltime, &tmp_fcontroltime, sizeof(tmp_fcontroltime));
  if (raw_fcontroltime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(47, this->_internal_fcontroltime(), target);
  }

  // double fLowerTime = 48;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertime = this->_internal_flowertime();
  uint64_t raw_flowertime;
  memcpy(&raw_flowertime, &tmp_flowertime, sizeof(tmp_flowertime));
  if (raw_flowertime != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(48, this->_internal_flowertime(), target);
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(51, this->_internal_fplus(), target);
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(52, this->_internal_fmaxrpm(), target);
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(53, this->_internal_fcut(), target);
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(54, this->_internal_frpmadj(), target);
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(55, this->_internal_fmulti(), target);
  }

  // double fMinShlSlope = 70;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fminshlslope = this->_internal_fminshlslope();
  uint64_t raw_fminshlslope;
  memcpy(&raw_fminshlslope, &tmp_fminshlslope, sizeof(tmp_fminshlslope));
  if (raw_fminshlslope != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(70, this->_internal_fminshlslope(), target);
  }

  // double fMaxDeltaCir = 71;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxdeltacir = this->_internal_fmaxdeltacir();
  uint64_t raw_fmaxdeltacir;
  memcpy(&raw_fmaxdeltacir, &tmp_fmaxdeltacir, sizeof(tmp_fmaxdeltacir));
  if (raw_fmaxdeltacir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(71, this->_internal_fmaxdeltacir(), target);
  }

  // double fMinDeltaCir = 72;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmindeltacir = this->_internal_fmindeltacir();
  uint64_t raw_fmindeltacir;
  memcpy(&raw_fmindeltacir, &tmp_fmindeltacir, sizeof(tmp_fmindeltacir));
  if (raw_fmindeltacir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(72, this->_internal_fmindeltacir(), target);
  }

  // double fMakeupDur = 73;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = this->_internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(73, this->_internal_fmakeupdur(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.Torque)
  return target;
}

size_t Torque::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.Torque)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double fTorque = 6 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ftorque_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double fRpm = 7 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_frpm_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated .TorqData.ShowInfo tShow = 8;
  total_size += 1UL * this->_internal_tshow_size();
  for (const auto& msg : this->_impl_.tshow_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 dwDelPlus = 13 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.dwdelplus_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dwdelplus_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // bytes llColTime = 15;
  if (!this->_internal_llcoltime().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_llcoltime());
  }

  // bytes strMemo = 22;
  if (!this->_internal_strmemo().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strmemo());
  }

  // bytes strRemark = 23;
  if (!this->_internal_strremark().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strremark());
  }

  // fixed64 coltime = 1;
  if (this->_internal_coltime() != 0) {
    total_size += 1 + 8;
  }

  // int32 dwSeqNo = 2;
  if (this->_internal_dwseqno() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwseqno());
  }

  // int32 dwQuality = 3;
  if (this->_internal_dwquality() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwquality());
  }

  // double fMaxTorq = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = this->_internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    total_size += 1 + 8;
  }

  // int32 dwIPPos = 4;
  if (this->_internal_dwippos() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwippos());
  }

  // int32 dwIPTorq = 10;
  if (this->_internal_dwiptorq() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwiptorq());
  }

  // fixed64 begintime = 9;
  if (this->_internal_begintime() != 0) {
    total_size += 1 + 8;
  }

  // int32 dwTotalPlus = 11;
  if (this->_internal_dwtotalplus() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwtotalplus());
  }

  // int32 dwIPPlus = 12;
  if (this->_internal_dwipplus() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwipplus());
  }

  // int32 dwColInter = 14;
  if (this->_internal_dwcolinter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwcolinter());
  }

  // int32 dwVer = 16;
  if (this->_internal_dwver() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwver());
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    total_size += 2 + 1;
  }

  // bool bNCheckIP = 24;
  if (this->_internal_bncheckip() != 0) {
    total_size += 2 + 1;
  }

  // bool bShackle = 25;
  if (this->_internal_bshackle() != 0) {
    total_size += 2 + 1;
  }

  // bool bTimeLine = 26;
  if (this->_internal_btimeline() != 0) {
    total_size += 2 + 1;
  }

  // int32 dwTorqUnit = 27;
  if (this->_internal_dwtorqunit() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwtorqunit());
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    total_size += 2 + 8;
  }

  // double fUpperLimit = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fupperlimit = this->_internal_fupperlimit();
  uint64_t raw_fupperlimit;
  memcpy(&raw_fupperlimit, &tmp_fupperlimit, sizeof(tmp_fupperlimit));
  if (raw_fupperlimit != 0) {
    total_size += 2 + 8;
  }

  // double fControl = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    total_size += 2 + 8;
  }

  // double fLowerLimit = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowerlimit = this->_internal_flowerlimit();
  uint64_t raw_flowerlimit;
  memcpy(&raw_flowerlimit, &tmp_flowerlimit, sizeof(tmp_flowerlimit));
  if (raw_flowerlimit != 0) {
    total_size += 2 + 8;
  }

  // double fSpeedDown = 35;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fspeeddown = this->_internal_fspeeddown();
  uint64_t raw_fspeeddown;
  memcpy(&raw_fspeeddown, &tmp_fspeeddown, sizeof(tmp_fspeeddown));
  if (raw_fspeeddown != 0) {
    total_size += 2 + 8;
  }

  // double fShow = 36;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    total_size += 2 + 8;
  }

  // double fBear = 37;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbear = this->_internal_fbear();
  uint64_t raw_fbear;
  memcpy(&raw_fbear, &tmp_fbear, sizeof(tmp_fbear));
  if (raw_fbear != 0) {
    total_size += 2 + 8;
  }

  // double fUpperTai = 38;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertai = this->_internal_fuppertai();
  uint64_t raw_fuppertai;
  memcpy(&raw_fuppertai, &tmp_fuppertai, sizeof(tmp_fuppertai));
  if (raw_fuppertai != 0) {
    total_size += 2 + 8;
  }

  // double fLowerTai = 39;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertai = this->_internal_flowertai();
  uint64_t raw_flowertai;
  memcpy(&raw_flowertai, &tmp_flowertai, sizeof(tmp_flowertai));
  if (raw_flowertai != 0) {
    total_size += 2 + 8;
  }

  // double fOptTorq = 40;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    total_size += 2 + 8;
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    total_size += 2 + 8;
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    total_size += 2 + 8;
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    total_size += 2 + 8;
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    total_size += 2 + 8;
  }

  // double fMaxTime = 45;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtime = this->_internal_fmaxtime();
  uint64_t raw_fmaxtime;
  memcpy(&raw_fmaxtime, &tmp_fmaxtime, sizeof(tmp_fmaxtime));
  if (raw_fmaxtime != 0) {
    total_size += 2 + 8;
  }

  // double fUpperTime = 46;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertime = this->_internal_fuppertime();
  uint64_t raw_fuppertime;
  memcpy(&raw_fuppertime, &tmp_fuppertime, sizeof(tmp_fuppertime));
  if (raw_fuppertime != 0) {
    total_size += 2 + 8;
  }

  // double fControlTime = 47;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontroltime = this->_internal_fcontroltime();
  uint64_t raw_fcontroltime;
  memcpy(&raw_fcontroltime, &tmp_fcontroltime, sizeof(tmp_fcontroltime));
  if (raw_fcontroltime != 0) {
    total_size += 2 + 8;
  }

  // double fLowerTime = 48;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertime = this->_internal_flowertime();
  uint64_t raw_flowertime;
  memcpy(&raw_flowertime, &tmp_flowertime, sizeof(tmp_flowertime));
  if (raw_flowertime != 0) {
    total_size += 2 + 8;
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    total_size += 2 + 8;
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    total_size += 2 + 8;
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    total_size += 2 + 8;
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    total_size += 2 + 8;
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    total_size += 2 + 8;
  }

  // double fMinShlSlope = 70;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fminshlslope = this->_internal_fminshlslope();
  uint64_t raw_fminshlslope;
  memcpy(&raw_fminshlslope, &tmp_fminshlslope, sizeof(tmp_fminshlslope));
  if (raw_fminshlslope != 0) {
    total_size += 2 + 8;
  }

  // double fMaxDeltaCir = 71;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxdeltacir = this->_internal_fmaxdeltacir();
  uint64_t raw_fmaxdeltacir;
  memcpy(&raw_fmaxdeltacir, &tmp_fmaxdeltacir, sizeof(tmp_fmaxdeltacir));
  if (raw_fmaxdeltacir != 0) {
    total_size += 2 + 8;
  }

  // double fMinDeltaCir = 72;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmindeltacir = this->_internal_fmindeltacir();
  uint64_t raw_fmindeltacir;
  memcpy(&raw_fmindeltacir, &tmp_fmindeltacir, sizeof(tmp_fmindeltacir));
  if (raw_fmindeltacir != 0) {
    total_size += 2 + 8;
  }

  // double fMakeupDur = 73;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = this->_internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    total_size += 2 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Torque::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Torque::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Torque::GetClassData() const { return &_class_data_; }


void Torque::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Torque*>(&to_msg);
  auto& from = static_cast<const Torque&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.Torque)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ftorque_.MergeFrom(from._impl_.ftorque_);
  _this->_impl_.frpm_.MergeFrom(from._impl_.frpm_);
  _this->_impl_.tshow_.MergeFrom(from._impl_.tshow_);
  _this->_impl_.dwdelplus_.MergeFrom(from._impl_.dwdelplus_);
  if (!from._internal_llcoltime().empty()) {
    _this->_internal_set_llcoltime(from._internal_llcoltime());
  }
  if (!from._internal_strmemo().empty()) {
    _this->_internal_set_strmemo(from._internal_strmemo());
  }
  if (!from._internal_strremark().empty()) {
    _this->_internal_set_strremark(from._internal_strremark());
  }
  if (from._internal_coltime() != 0) {
    _this->_internal_set_coltime(from._internal_coltime());
  }
  if (from._internal_dwseqno() != 0) {
    _this->_internal_set_dwseqno(from._internal_dwseqno());
  }
  if (from._internal_dwquality() != 0) {
    _this->_internal_set_dwquality(from._internal_dwquality());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtorq = from._internal_fmaxtorq();
  uint64_t raw_fmaxtorq;
  memcpy(&raw_fmaxtorq, &tmp_fmaxtorq, sizeof(tmp_fmaxtorq));
  if (raw_fmaxtorq != 0) {
    _this->_internal_set_fmaxtorq(from._internal_fmaxtorq());
  }
  if (from._internal_dwippos() != 0) {
    _this->_internal_set_dwippos(from._internal_dwippos());
  }
  if (from._internal_dwiptorq() != 0) {
    _this->_internal_set_dwiptorq(from._internal_dwiptorq());
  }
  if (from._internal_begintime() != 0) {
    _this->_internal_set_begintime(from._internal_begintime());
  }
  if (from._internal_dwtotalplus() != 0) {
    _this->_internal_set_dwtotalplus(from._internal_dwtotalplus());
  }
  if (from._internal_dwipplus() != 0) {
    _this->_internal_set_dwipplus(from._internal_dwipplus());
  }
  if (from._internal_dwcolinter() != 0) {
    _this->_internal_set_dwcolinter(from._internal_dwcolinter());
  }
  if (from._internal_dwver() != 0) {
    _this->_internal_set_dwver(from._internal_dwver());
  }
  if (from._internal_btoolbuck() != 0) {
    _this->_internal_set_btoolbuck(from._internal_btoolbuck());
  }
  if (from._internal_bncheckip() != 0) {
    _this->_internal_set_bncheckip(from._internal_bncheckip());
  }
  if (from._internal_bshackle() != 0) {
    _this->_internal_set_bshackle(from._internal_bshackle());
  }
  if (from._internal_btimeline() != 0) {
    _this->_internal_set_btimeline(from._internal_btimeline());
  }
  if (from._internal_dwtorqunit() != 0) {
    _this->_internal_set_dwtorqunit(from._internal_dwtorqunit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = from._internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    _this->_internal_set_fmaxlimit(from._internal_fmaxlimit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fupperlimit = from._internal_fupperlimit();
  uint64_t raw_fupperlimit;
  memcpy(&raw_fupperlimit, &tmp_fupperlimit, sizeof(tmp_fupperlimit));
  if (raw_fupperlimit != 0) {
    _this->_internal_set_fupperlimit(from._internal_fupperlimit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = from._internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    _this->_internal_set_fcontrol(from._internal_fcontrol());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowerlimit = from._internal_flowerlimit();
  uint64_t raw_flowerlimit;
  memcpy(&raw_flowerlimit, &tmp_flowerlimit, sizeof(tmp_flowerlimit));
  if (raw_flowerlimit != 0) {
    _this->_internal_set_flowerlimit(from._internal_flowerlimit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fspeeddown = from._internal_fspeeddown();
  uint64_t raw_fspeeddown;
  memcpy(&raw_fspeeddown, &tmp_fspeeddown, sizeof(tmp_fspeeddown));
  if (raw_fspeeddown != 0) {
    _this->_internal_set_fspeeddown(from._internal_fspeeddown());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = from._internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    _this->_internal_set_fshow(from._internal_fshow());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbear = from._internal_fbear();
  uint64_t raw_fbear;
  memcpy(&raw_fbear, &tmp_fbear, sizeof(tmp_fbear));
  if (raw_fbear != 0) {
    _this->_internal_set_fbear(from._internal_fbear());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertai = from._internal_fuppertai();
  uint64_t raw_fuppertai;
  memcpy(&raw_fuppertai, &tmp_fuppertai, sizeof(tmp_fuppertai));
  if (raw_fuppertai != 0) {
    _this->_internal_set_fuppertai(from._internal_fuppertai());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertai = from._internal_flowertai();
  uint64_t raw_flowertai;
  memcpy(&raw_flowertai, &tmp_flowertai, sizeof(tmp_flowertai));
  if (raw_flowertai != 0) {
    _this->_internal_set_flowertai(from._internal_flowertai());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = from._internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    _this->_internal_set_fopttorq(from._internal_fopttorq());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = from._internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    _this->_internal_set_fmaxcir(from._internal_fmaxcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = from._internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    _this->_internal_set_fuppercir(from._internal_fuppercir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = from._internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    _this->_internal_set_fcontrolcir(from._internal_fcontrolcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = from._internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    _this->_internal_set_flowercir(from._internal_flowercir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxtime = from._internal_fmaxtime();
  uint64_t raw_fmaxtime;
  memcpy(&raw_fmaxtime, &tmp_fmaxtime, sizeof(tmp_fmaxtime));
  if (raw_fmaxtime != 0) {
    _this->_internal_set_fmaxtime(from._internal_fmaxtime());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppertime = from._internal_fuppertime();
  uint64_t raw_fuppertime;
  memcpy(&raw_fuppertime, &tmp_fuppertime, sizeof(tmp_fuppertime));
  if (raw_fuppertime != 0) {
    _this->_internal_set_fuppertime(from._internal_fuppertime());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontroltime = from._internal_fcontroltime();
  uint64_t raw_fcontroltime;
  memcpy(&raw_fcontroltime, &tmp_fcontroltime, sizeof(tmp_fcontroltime));
  if (raw_fcontroltime != 0) {
    _this->_internal_set_fcontroltime(from._internal_fcontroltime());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowertime = from._internal_flowertime();
  uint64_t raw_flowertime;
  memcpy(&raw_flowertime, &tmp_flowertime, sizeof(tmp_flowertime));
  if (raw_flowertime != 0) {
    _this->_internal_set_flowertime(from._internal_flowertime());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = from._internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    _this->_internal_set_fplus(from._internal_fplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = from._internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    _this->_internal_set_fmaxrpm(from._internal_fmaxrpm());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = from._internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    _this->_internal_set_fcut(from._internal_fcut());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = from._internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    _this->_internal_set_frpmadj(from._internal_frpmadj());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = from._internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    _this->_internal_set_fmulti(from._internal_fmulti());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fminshlslope = from._internal_fminshlslope();
  uint64_t raw_fminshlslope;
  memcpy(&raw_fminshlslope, &tmp_fminshlslope, sizeof(tmp_fminshlslope));
  if (raw_fminshlslope != 0) {
    _this->_internal_set_fminshlslope(from._internal_fminshlslope());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxdeltacir = from._internal_fmaxdeltacir();
  uint64_t raw_fmaxdeltacir;
  memcpy(&raw_fmaxdeltacir, &tmp_fmaxdeltacir, sizeof(tmp_fmaxdeltacir));
  if (raw_fmaxdeltacir != 0) {
    _this->_internal_set_fmaxdeltacir(from._internal_fmaxdeltacir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmindeltacir = from._internal_fmindeltacir();
  uint64_t raw_fmindeltacir;
  memcpy(&raw_fmindeltacir, &tmp_fmindeltacir, sizeof(tmp_fmindeltacir));
  if (raw_fmindeltacir != 0) {
    _this->_internal_set_fmindeltacir(from._internal_fmindeltacir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmakeupdur = from._internal_fmakeupdur();
  uint64_t raw_fmakeupdur;
  memcpy(&raw_fmakeupdur, &tmp_fmakeupdur, sizeof(tmp_fmakeupdur));
  if (raw_fmakeupdur != 0) {
    _this->_internal_set_fmakeupdur(from._internal_fmakeupdur());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Torque::CopyFrom(const Torque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.Torque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Torque::IsInitialized() const {
  return true;
}

void Torque::InternalSwap(Torque* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ftorque_.InternalSwap(&other->_impl_.ftorque_);
  _impl_.frpm_.InternalSwap(&other->_impl_.frpm_);
  _impl_.tshow_.InternalSwap(&other->_impl_.tshow_);
  _impl_.dwdelplus_.InternalSwap(&other->_impl_.dwdelplus_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.llcoltime_, lhs_arena,
      &other->_impl_.llcoltime_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strmemo_, lhs_arena,
      &other->_impl_.strmemo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strremark_, lhs_arena,
      &other->_impl_.strremark_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Torque, _impl_.fmakeupdur_)
      + sizeof(Torque::_impl_.fmakeupdur_)
      - PROTOBUF_FIELD_OFFSET(Torque, _impl_.coltime_)>(
          reinterpret_cast<char*>(&_impl_.coltime_),
          reinterpret_cast<char*>(&other->_impl_.coltime_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Torque::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_TorqData_2eproto_getter, &descriptor_table_TorqData_2eproto_once,
      file_level_metadata_TorqData_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TorqData
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TorqData::ShowInfo*
Arena::CreateMaybeMessage< ::TorqData::ShowInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::ShowInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::TorqData::Torque*
Arena::CreateMaybeMessage< ::TorqData::Torque >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::Torque >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
