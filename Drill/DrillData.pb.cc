// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: DrillData.proto

#include "DrillData.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace TorqData {
PROTOBUF_CONSTEXPR ShowInfo::ShowInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.strvalue_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShowInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShowInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShowInfoDefaultTypeInternal() {}
  union {
    ShowInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShowInfoDefaultTypeInternal _ShowInfo_default_instance_;
PROTOBUF_CONSTEXPR Torque::Torque(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ftorque_)*/{}
  , /*decltype(_impl_.frpm_)*/{}
  , /*decltype(_impl_.dwdelplus_)*/{}
  , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
  , /*decltype(_impl_.tshow_)*/{}
  , /*decltype(_impl_.strmemo_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strremark_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.strbojoint_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dwseqno_)*/0
  , /*decltype(_impl_.dwquality_)*/0
  , /*decltype(_impl_.dwcolinter_)*/0
  , /*decltype(_impl_.btoolbuck_)*/false
  , /*decltype(_impl_.bsinglestd_)*/false
  , /*decltype(_impl_.dwtorqunit_)*/0
  , /*decltype(_impl_.dwcolumns_)*/0
  , /*decltype(_impl_.fmaxlimit_)*/0
  , /*decltype(_impl_.fcontrol_)*/0
  , /*decltype(_impl_.fshow_)*/0
  , /*decltype(_impl_.fopttorq_)*/0
  , /*decltype(_impl_.fmaxcir_)*/0
  , /*decltype(_impl_.fuppercir_)*/0
  , /*decltype(_impl_.fcontrolcir_)*/0
  , /*decltype(_impl_.flowercir_)*/0
  , /*decltype(_impl_.fplus_)*/0
  , /*decltype(_impl_.fmaxrpm_)*/0
  , /*decltype(_impl_.fcut_)*/0
  , /*decltype(_impl_.frpmadj_)*/0
  , /*decltype(_impl_.fmulti_)*/0
  , /*decltype(_impl_.mucoltime_)*/uint64_t{0u}
  , /*decltype(_impl_.dwmucount_)*/0
  , /*decltype(_impl_.dwmuplus_)*/0
  , /*decltype(_impl_.fmumaxtorq_)*/0
  , /*decltype(_impl_.fmuduration_)*/0
  , /*decltype(_impl_.bocoltime_)*/uint64_t{0u}
  , /*decltype(_impl_.dwoutwellno_)*/0
  , /*decltype(_impl_.dwbocount_)*/0
  , /*decltype(_impl_.fbomaxtorq_)*/0
  , /*decltype(_impl_.fboduration_)*/0
  , /*decltype(_impl_.dwboplus_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TorqueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TorqueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TorqueDefaultTypeInternal() {}
  union {
    Torque _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TorqueDefaultTypeInternal _Torque_default_instance_;
}  // namespace TorqData
static ::_pb::Metadata file_level_metadata_DrillData_2eproto[2];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_DrillData_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_DrillData_2eproto = nullptr;

const uint32_t TableStruct_DrillData_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strvalue_),
  PROTOBUF_FIELD_OFFSET(::TorqData::ShowInfo, _impl_.strname_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.ftorque_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwdelplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.tshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwseqno_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwquality_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwcolinter_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.btoolbuck_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.bsinglestd_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strmemo_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strremark_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwtorqunit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwcolumns_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxlimit_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrol_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fshow_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fopttorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fuppercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcontrolcir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.flowercir_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmaxrpm_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fcut_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.frpmadj_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmulti_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.mucoltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwmucount_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwmuplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmumaxtorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fmuduration_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwoutwellno_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.bocoltime_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwbocount_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.dwboplus_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fbomaxtorq_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.fboduration_),
  PROTOBUF_FIELD_OFFSET(::TorqData::Torque, _impl_.strbojoint_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::TorqData::ShowInfo)},
  { 8, -1, -1, sizeof(::TorqData::Torque)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::TorqData::_ShowInfo_default_instance_._instance,
  &::TorqData::_Torque_default_instance_._instance,
};

const char descriptor_table_protodef_DrillData_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017DrillData.proto\022\010TorqData\"-\n\010ShowInfo\022"
  "\020\n\010strValue\030\002 \001(\014\022\017\n\007strName\030\003 \001(\014\"\337\005\n\006T"
  "orque\022\023\n\007fTorque\030\001 \003(\001B\002\020\001\022\020\n\004fRpm\030\002 \003(\001"
  "B\002\020\001\022\025\n\tdwDelPlus\030\003 \003(\005B\002\020\001\022!\n\005tShow\030\004 \003"
  "(\0132\022.TorqData.ShowInfo\022\017\n\007dwSeqNo\030\013 \001(\005\022"
  "\021\n\tdwQuality\030\014 \001(\005\022\022\n\ndwColInter\030\r \001(\005\022\021"
  "\n\tbToolBuck\030\025 \001(\010\022\022\n\nbSingleSTD\030\026 \001(\010\022\017\n"
  "\007strMemo\030\027 \001(\014\022\021\n\tstrRemark\030\030 \001(\014\022\022\n\ndwT"
  "orqUnit\030\031 \001(\005\022\021\n\tdwColumns\030\032 \001(\005\022\021\n\tfMax"
  "Limit\030\037 \001(\001\022\020\n\010fControl\030  \001(\001\022\r\n\005fShow\030!"
  " \001(\001\022\020\n\010fOptTorq\030\" \001(\001\022\017\n\007fMaxCir\030) \001(\001\022"
  "\021\n\tfUpperCir\030* \001(\001\022\023\n\013fControlCir\030+ \001(\001\022"
  "\021\n\tfLowerCir\030, \001(\001\022\r\n\005fPlus\0303 \001(\001\022\017\n\007fMa"
  "xRPM\0304 \001(\001\022\014\n\004fCut\0305 \001(\001\022\017\n\007fRpmAdj\0306 \001("
  "\001\022\016\n\006fMulti\0307 \001(\001\022\021\n\tMUcoltime\030G \001(\006\022\021\n\t"
  "dwMUCount\030H \001(\005\022\020\n\010dwMUPlus\030I \001(\005\022\022\n\nfMU"
  "MaxTorq\030J \001(\001\022\023\n\013fMUDuration\030K \001(\001\022\023\n\013dw"
  "OutWellNO\030P \001(\005\022\021\n\tBOcoltime\030Q \001(\006\022\021\n\tdw"
  "BOCount\030R \001(\005\022\020\n\010dwBOPlus\030S \001(\005\022\022\n\nfBOMa"
  "xTorq\030T \001(\001\022\023\n\013fBODuration\030U \001(\001\022\022\n\nstrB"
  "OJoint\030V \001(\014b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_DrillData_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_DrillData_2eproto = {
    false, false, 820, descriptor_table_protodef_DrillData_2eproto,
    "DrillData.proto",
    &descriptor_table_DrillData_2eproto_once, nullptr, 0, 2,
    schemas, file_default_instances, TableStruct_DrillData_2eproto::offsets,
    file_level_metadata_DrillData_2eproto, file_level_enum_descriptors_DrillData_2eproto,
    file_level_service_descriptors_DrillData_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_DrillData_2eproto_getter() {
  return &descriptor_table_DrillData_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_DrillData_2eproto(&descriptor_table_DrillData_2eproto);
namespace TorqData {

// ===================================================================

class ShowInfo::_Internal {
 public:
};

ShowInfo::ShowInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.ShowInfo)
}
ShowInfo::ShowInfo(const ShowInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShowInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strvalue().empty()) {
    _this->_impl_.strvalue_.Set(from._internal_strvalue(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strname().empty()) {
    _this->_impl_.strname_.Set(from._internal_strname(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:TorqData.ShowInfo)
}

inline void ShowInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.strvalue_){}
    , decltype(_impl_.strname_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.strvalue_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strvalue_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShowInfo::~ShowInfo() {
  // @@protoc_insertion_point(destructor:TorqData.ShowInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShowInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.strvalue_.Destroy();
  _impl_.strname_.Destroy();
}

void ShowInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShowInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.strvalue_.ClearToEmpty();
  _impl_.strname_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShowInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes strValue = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_strvalue();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strName = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_strname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShowInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.ShowInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_strvalue(), target);
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_strname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.ShowInfo)
  return target;
}

size_t ShowInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.ShowInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes strValue = 2;
  if (!this->_internal_strvalue().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strvalue());
  }

  // bytes strName = 3;
  if (!this->_internal_strname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShowInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShowInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShowInfo::GetClassData() const { return &_class_data_; }


void ShowInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShowInfo*>(&to_msg);
  auto& from = static_cast<const ShowInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.ShowInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_strvalue().empty()) {
    _this->_internal_set_strvalue(from._internal_strvalue());
  }
  if (!from._internal_strname().empty()) {
    _this->_internal_set_strname(from._internal_strname());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShowInfo::CopyFrom(const ShowInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.ShowInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShowInfo::IsInitialized() const {
  return true;
}

void ShowInfo::InternalSwap(ShowInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strvalue_, lhs_arena,
      &other->_impl_.strvalue_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strname_, lhs_arena,
      &other->_impl_.strname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata ShowInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DrillData_2eproto_getter, &descriptor_table_DrillData_2eproto_once,
      file_level_metadata_DrillData_2eproto[0]);
}

// ===================================================================

class Torque::_Internal {
 public:
};

Torque::Torque(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:TorqData.Torque)
}
Torque::Torque(const Torque& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Torque* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){from._impl_.ftorque_}
    , decltype(_impl_.frpm_){from._impl_.frpm_}
    , decltype(_impl_.dwdelplus_){from._impl_.dwdelplus_}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.tshow_){from._impl_.tshow_}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.strbojoint_){}
    , decltype(_impl_.dwseqno_){}
    , decltype(_impl_.dwquality_){}
    , decltype(_impl_.dwcolinter_){}
    , decltype(_impl_.btoolbuck_){}
    , decltype(_impl_.bsinglestd_){}
    , decltype(_impl_.dwtorqunit_){}
    , decltype(_impl_.dwcolumns_){}
    , decltype(_impl_.fmaxlimit_){}
    , decltype(_impl_.fcontrol_){}
    , decltype(_impl_.fshow_){}
    , decltype(_impl_.fopttorq_){}
    , decltype(_impl_.fmaxcir_){}
    , decltype(_impl_.fuppercir_){}
    , decltype(_impl_.fcontrolcir_){}
    , decltype(_impl_.flowercir_){}
    , decltype(_impl_.fplus_){}
    , decltype(_impl_.fmaxrpm_){}
    , decltype(_impl_.fcut_){}
    , decltype(_impl_.frpmadj_){}
    , decltype(_impl_.fmulti_){}
    , decltype(_impl_.mucoltime_){}
    , decltype(_impl_.dwmucount_){}
    , decltype(_impl_.dwmuplus_){}
    , decltype(_impl_.fmumaxtorq_){}
    , decltype(_impl_.fmuduration_){}
    , decltype(_impl_.bocoltime_){}
    , decltype(_impl_.dwoutwellno_){}
    , decltype(_impl_.dwbocount_){}
    , decltype(_impl_.fbomaxtorq_){}
    , decltype(_impl_.fboduration_){}
    , decltype(_impl_.dwboplus_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strmemo().empty()) {
    _this->_impl_.strmemo_.Set(from._internal_strmemo(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strremark().empty()) {
    _this->_impl_.strremark_.Set(from._internal_strremark(), 
      _this->GetArenaForAllocation());
  }
  _impl_.strbojoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strbojoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_strbojoint().empty()) {
    _this->_impl_.strbojoint_.Set(from._internal_strbojoint(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.dwseqno_, &from._impl_.dwseqno_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dwboplus_) -
    reinterpret_cast<char*>(&_impl_.dwseqno_)) + sizeof(_impl_.dwboplus_));
  // @@protoc_insertion_point(copy_constructor:TorqData.Torque)
}

inline void Torque::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ftorque_){arena}
    , decltype(_impl_.frpm_){arena}
    , decltype(_impl_.dwdelplus_){arena}
    , /*decltype(_impl_._dwdelplus_cached_byte_size_)*/{0}
    , decltype(_impl_.tshow_){arena}
    , decltype(_impl_.strmemo_){}
    , decltype(_impl_.strremark_){}
    , decltype(_impl_.strbojoint_){}
    , decltype(_impl_.dwseqno_){0}
    , decltype(_impl_.dwquality_){0}
    , decltype(_impl_.dwcolinter_){0}
    , decltype(_impl_.btoolbuck_){false}
    , decltype(_impl_.bsinglestd_){false}
    , decltype(_impl_.dwtorqunit_){0}
    , decltype(_impl_.dwcolumns_){0}
    , decltype(_impl_.fmaxlimit_){0}
    , decltype(_impl_.fcontrol_){0}
    , decltype(_impl_.fshow_){0}
    , decltype(_impl_.fopttorq_){0}
    , decltype(_impl_.fmaxcir_){0}
    , decltype(_impl_.fuppercir_){0}
    , decltype(_impl_.fcontrolcir_){0}
    , decltype(_impl_.flowercir_){0}
    , decltype(_impl_.fplus_){0}
    , decltype(_impl_.fmaxrpm_){0}
    , decltype(_impl_.fcut_){0}
    , decltype(_impl_.frpmadj_){0}
    , decltype(_impl_.fmulti_){0}
    , decltype(_impl_.mucoltime_){uint64_t{0u}}
    , decltype(_impl_.dwmucount_){0}
    , decltype(_impl_.dwmuplus_){0}
    , decltype(_impl_.fmumaxtorq_){0}
    , decltype(_impl_.fmuduration_){0}
    , decltype(_impl_.bocoltime_){uint64_t{0u}}
    , decltype(_impl_.dwoutwellno_){0}
    , decltype(_impl_.dwbocount_){0}
    , decltype(_impl_.fbomaxtorq_){0}
    , decltype(_impl_.fboduration_){0}
    , decltype(_impl_.dwboplus_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.strmemo_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strmemo_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strremark_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strremark_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.strbojoint_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.strbojoint_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Torque::~Torque() {
  // @@protoc_insertion_point(destructor:TorqData.Torque)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Torque::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ftorque_.~RepeatedField();
  _impl_.frpm_.~RepeatedField();
  _impl_.dwdelplus_.~RepeatedField();
  _impl_.tshow_.~RepeatedPtrField();
  _impl_.strmemo_.Destroy();
  _impl_.strremark_.Destroy();
  _impl_.strbojoint_.Destroy();
}

void Torque::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Torque::Clear() {
// @@protoc_insertion_point(message_clear_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ftorque_.Clear();
  _impl_.frpm_.Clear();
  _impl_.dwdelplus_.Clear();
  _impl_.tshow_.Clear();
  _impl_.strmemo_.ClearToEmpty();
  _impl_.strremark_.ClearToEmpty();
  _impl_.strbojoint_.ClearToEmpty();
  ::memset(&_impl_.dwseqno_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.dwboplus_) -
      reinterpret_cast<char*>(&_impl_.dwseqno_)) + sizeof(_impl_.dwboplus_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Torque::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated double fTorque = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_ftorque(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 9) {
          _internal_add_ftorque(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated double fRpm = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedDoubleParser(_internal_mutable_frpm(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 17) {
          _internal_add_frpm(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dwDelPlus = 3 [packed = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dwdelplus(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_dwdelplus(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .TorqData.ShowInfo tShow = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tshow(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 dwSeqNo = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _impl_.dwseqno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwQuality = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _impl_.dwquality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwColInter = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _impl_.dwcolinter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bToolBuck = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _impl_.btoolbuck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool bSingleSTD = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _impl_.bsinglestd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strMemo = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          auto str = _internal_mutable_strmemo();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes strRemark = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          auto str = _internal_mutable_strremark();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwTorqUnit = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _impl_.dwtorqunit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwColumns = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _impl_.dwcolumns_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMaxLimit = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 249)) {
          _impl_.fmaxlimit_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControl = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 1)) {
          _impl_.fcontrol_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fShow = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _impl_.fshow_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fOptTorq = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _impl_.fopttorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxCir = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 73)) {
          _impl_.fmaxcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fUpperCir = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.fuppercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fControlCir = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.fcontrolcir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fLowerCir = 44;
      case 44:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _impl_.flowercir_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fPlus = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _impl_.fplus_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMaxRPM = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.fmaxrpm_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fCut = 53;
      case 53:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _impl_.fcut_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fRpmAdj = 54;
      case 54:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 177)) {
          _impl_.frpmadj_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMulti = 55;
      case 55:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 185)) {
          _impl_.fmulti_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // fixed64 MUcoltime = 71;
      case 71:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 57)) {
          _impl_.mucoltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 dwMUCount = 72;
      case 72:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.dwmucount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwMUPlus = 73;
      case 73:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.dwmuplus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fMUMaxTorq = 74;
      case 74:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 81)) {
          _impl_.fmumaxtorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fMUDuration = 75;
      case 75:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _impl_.fmuduration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // int32 dwOutWellNO = 80;
      case 80:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _impl_.dwoutwellno_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // fixed64 BOcoltime = 81;
      case 81:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 137)) {
          _impl_.bocoltime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // int32 dwBOCount = 82;
      case 82:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _impl_.dwbocount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 dwBOPlus = 83;
      case 83:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _impl_.dwboplus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double fBOMaxTorq = 84;
      case 84:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 161)) {
          _impl_.fbomaxtorq_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // double fBODuration = 85;
      case 85:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 169)) {
          _impl_.fboduration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bytes strBOJoint = 86;
      case 86:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          auto str = _internal_mutable_strbojoint();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Torque::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:TorqData.Torque)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated double fTorque = 1 [packed = true];
  if (this->_internal_ftorque_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_ftorque(), target);
  }

  // repeated double fRpm = 2 [packed = true];
  if (this->_internal_frpm_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_frpm(), target);
  }

  // repeated int32 dwDelPlus = 3 [packed = true];
  {
    int byte_size = _impl_._dwdelplus_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          3, _internal_dwdelplus(), byte_size, target);
    }
  }

  // repeated .TorqData.ShowInfo tShow = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tshow_size()); i < n; i++) {
    const auto& repfield = this->_internal_tshow(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // int32 dwSeqNo = 11;
  if (this->_internal_dwseqno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_dwseqno(), target);
  }

  // int32 dwQuality = 12;
  if (this->_internal_dwquality() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_dwquality(), target);
  }

  // int32 dwColInter = 13;
  if (this->_internal_dwcolinter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_dwcolinter(), target);
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_btoolbuck(), target);
  }

  // bool bSingleSTD = 22;
  if (this->_internal_bsinglestd() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_bsinglestd(), target);
  }

  // bytes strMemo = 23;
  if (!this->_internal_strmemo().empty()) {
    target = stream->WriteBytesMaybeAliased(
        23, this->_internal_strmemo(), target);
  }

  // bytes strRemark = 24;
  if (!this->_internal_strremark().empty()) {
    target = stream->WriteBytesMaybeAliased(
        24, this->_internal_strremark(), target);
  }

  // int32 dwTorqUnit = 25;
  if (this->_internal_dwtorqunit() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(25, this->_internal_dwtorqunit(), target);
  }

  // int32 dwColumns = 26;
  if (this->_internal_dwcolumns() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(26, this->_internal_dwcolumns(), target);
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(31, this->_internal_fmaxlimit(), target);
  }

  // double fControl = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(32, this->_internal_fcontrol(), target);
  }

  // double fShow = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(33, this->_internal_fshow(), target);
  }

  // double fOptTorq = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(34, this->_internal_fopttorq(), target);
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(41, this->_internal_fmaxcir(), target);
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(42, this->_internal_fuppercir(), target);
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(43, this->_internal_fcontrolcir(), target);
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(44, this->_internal_flowercir(), target);
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(51, this->_internal_fplus(), target);
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(52, this->_internal_fmaxrpm(), target);
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(53, this->_internal_fcut(), target);
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(54, this->_internal_frpmadj(), target);
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(55, this->_internal_fmulti(), target);
  }

  // fixed64 MUcoltime = 71;
  if (this->_internal_mucoltime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(71, this->_internal_mucoltime(), target);
  }

  // int32 dwMUCount = 72;
  if (this->_internal_dwmucount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(72, this->_internal_dwmucount(), target);
  }

  // int32 dwMUPlus = 73;
  if (this->_internal_dwmuplus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(73, this->_internal_dwmuplus(), target);
  }

  // double fMUMaxTorq = 74;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmumaxtorq = this->_internal_fmumaxtorq();
  uint64_t raw_fmumaxtorq;
  memcpy(&raw_fmumaxtorq, &tmp_fmumaxtorq, sizeof(tmp_fmumaxtorq));
  if (raw_fmumaxtorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(74, this->_internal_fmumaxtorq(), target);
  }

  // double fMUDuration = 75;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmuduration = this->_internal_fmuduration();
  uint64_t raw_fmuduration;
  memcpy(&raw_fmuduration, &tmp_fmuduration, sizeof(tmp_fmuduration));
  if (raw_fmuduration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(75, this->_internal_fmuduration(), target);
  }

  // int32 dwOutWellNO = 80;
  if (this->_internal_dwoutwellno() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(80, this->_internal_dwoutwellno(), target);
  }

  // fixed64 BOcoltime = 81;
  if (this->_internal_bocoltime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(81, this->_internal_bocoltime(), target);
  }

  // int32 dwBOCount = 82;
  if (this->_internal_dwbocount() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(82, this->_internal_dwbocount(), target);
  }

  // int32 dwBOPlus = 83;
  if (this->_internal_dwboplus() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(83, this->_internal_dwboplus(), target);
  }

  // double fBOMaxTorq = 84;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbomaxtorq = this->_internal_fbomaxtorq();
  uint64_t raw_fbomaxtorq;
  memcpy(&raw_fbomaxtorq, &tmp_fbomaxtorq, sizeof(tmp_fbomaxtorq));
  if (raw_fbomaxtorq != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(84, this->_internal_fbomaxtorq(), target);
  }

  // double fBODuration = 85;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fboduration = this->_internal_fboduration();
  uint64_t raw_fboduration;
  memcpy(&raw_fboduration, &tmp_fboduration, sizeof(tmp_fboduration));
  if (raw_fboduration != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(85, this->_internal_fboduration(), target);
  }

  // bytes strBOJoint = 86;
  if (!this->_internal_strbojoint().empty()) {
    target = stream->WriteBytesMaybeAliased(
        86, this->_internal_strbojoint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:TorqData.Torque)
  return target;
}

size_t Torque::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:TorqData.Torque)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated double fTorque = 1 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_ftorque_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated double fRpm = 2 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_frpm_size());
    size_t data_size = 8UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated int32 dwDelPlus = 3 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.dwdelplus_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._dwdelplus_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .TorqData.ShowInfo tShow = 4;
  total_size += 1UL * this->_internal_tshow_size();
  for (const auto& msg : this->_impl_.tshow_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bytes strMemo = 23;
  if (!this->_internal_strmemo().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strmemo());
  }

  // bytes strRemark = 24;
  if (!this->_internal_strremark().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strremark());
  }

  // bytes strBOJoint = 86;
  if (!this->_internal_strbojoint().empty()) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_strbojoint());
  }

  // int32 dwSeqNo = 11;
  if (this->_internal_dwseqno() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwseqno());
  }

  // int32 dwQuality = 12;
  if (this->_internal_dwquality() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwquality());
  }

  // int32 dwColInter = 13;
  if (this->_internal_dwcolinter() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dwcolinter());
  }

  // bool bToolBuck = 21;
  if (this->_internal_btoolbuck() != 0) {
    total_size += 2 + 1;
  }

  // bool bSingleSTD = 22;
  if (this->_internal_bsinglestd() != 0) {
    total_size += 2 + 1;
  }

  // int32 dwTorqUnit = 25;
  if (this->_internal_dwtorqunit() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwtorqunit());
  }

  // int32 dwColumns = 26;
  if (this->_internal_dwcolumns() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwcolumns());
  }

  // double fMaxLimit = 31;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = this->_internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    total_size += 2 + 8;
  }

  // double fControl = 32;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = this->_internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    total_size += 2 + 8;
  }

  // double fShow = 33;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = this->_internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    total_size += 2 + 8;
  }

  // double fOptTorq = 34;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = this->_internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    total_size += 2 + 8;
  }

  // double fMaxCir = 41;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = this->_internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    total_size += 2 + 8;
  }

  // double fUpperCir = 42;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = this->_internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    total_size += 2 + 8;
  }

  // double fControlCir = 43;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = this->_internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    total_size += 2 + 8;
  }

  // double fLowerCir = 44;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = this->_internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    total_size += 2 + 8;
  }

  // double fPlus = 51;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = this->_internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    total_size += 2 + 8;
  }

  // double fMaxRPM = 52;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = this->_internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    total_size += 2 + 8;
  }

  // double fCut = 53;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = this->_internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    total_size += 2 + 8;
  }

  // double fRpmAdj = 54;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = this->_internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    total_size += 2 + 8;
  }

  // double fMulti = 55;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = this->_internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    total_size += 2 + 8;
  }

  // fixed64 MUcoltime = 71;
  if (this->_internal_mucoltime() != 0) {
    total_size += 2 + 8;
  }

  // int32 dwMUCount = 72;
  if (this->_internal_dwmucount() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwmucount());
  }

  // int32 dwMUPlus = 73;
  if (this->_internal_dwmuplus() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwmuplus());
  }

  // double fMUMaxTorq = 74;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmumaxtorq = this->_internal_fmumaxtorq();
  uint64_t raw_fmumaxtorq;
  memcpy(&raw_fmumaxtorq, &tmp_fmumaxtorq, sizeof(tmp_fmumaxtorq));
  if (raw_fmumaxtorq != 0) {
    total_size += 2 + 8;
  }

  // double fMUDuration = 75;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmuduration = this->_internal_fmuduration();
  uint64_t raw_fmuduration;
  memcpy(&raw_fmuduration, &tmp_fmuduration, sizeof(tmp_fmuduration));
  if (raw_fmuduration != 0) {
    total_size += 2 + 8;
  }

  // fixed64 BOcoltime = 81;
  if (this->_internal_bocoltime() != 0) {
    total_size += 2 + 8;
  }

  // int32 dwOutWellNO = 80;
  if (this->_internal_dwoutwellno() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwoutwellno());
  }

  // int32 dwBOCount = 82;
  if (this->_internal_dwbocount() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwbocount());
  }

  // double fBOMaxTorq = 84;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbomaxtorq = this->_internal_fbomaxtorq();
  uint64_t raw_fbomaxtorq;
  memcpy(&raw_fbomaxtorq, &tmp_fbomaxtorq, sizeof(tmp_fbomaxtorq));
  if (raw_fbomaxtorq != 0) {
    total_size += 2 + 8;
  }

  // double fBODuration = 85;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fboduration = this->_internal_fboduration();
  uint64_t raw_fboduration;
  memcpy(&raw_fboduration, &tmp_fboduration, sizeof(tmp_fboduration));
  if (raw_fboduration != 0) {
    total_size += 2 + 8;
  }

  // int32 dwBOPlus = 83;
  if (this->_internal_dwboplus() != 0) {
    total_size += 2 +
      ::_pbi::WireFormatLite::Int32Size(
        this->_internal_dwboplus());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Torque::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Torque::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Torque::GetClassData() const { return &_class_data_; }


void Torque::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Torque*>(&to_msg);
  auto& from = static_cast<const Torque&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:TorqData.Torque)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ftorque_.MergeFrom(from._impl_.ftorque_);
  _this->_impl_.frpm_.MergeFrom(from._impl_.frpm_);
  _this->_impl_.dwdelplus_.MergeFrom(from._impl_.dwdelplus_);
  _this->_impl_.tshow_.MergeFrom(from._impl_.tshow_);
  if (!from._internal_strmemo().empty()) {
    _this->_internal_set_strmemo(from._internal_strmemo());
  }
  if (!from._internal_strremark().empty()) {
    _this->_internal_set_strremark(from._internal_strremark());
  }
  if (!from._internal_strbojoint().empty()) {
    _this->_internal_set_strbojoint(from._internal_strbojoint());
  }
  if (from._internal_dwseqno() != 0) {
    _this->_internal_set_dwseqno(from._internal_dwseqno());
  }
  if (from._internal_dwquality() != 0) {
    _this->_internal_set_dwquality(from._internal_dwquality());
  }
  if (from._internal_dwcolinter() != 0) {
    _this->_internal_set_dwcolinter(from._internal_dwcolinter());
  }
  if (from._internal_btoolbuck() != 0) {
    _this->_internal_set_btoolbuck(from._internal_btoolbuck());
  }
  if (from._internal_bsinglestd() != 0) {
    _this->_internal_set_bsinglestd(from._internal_bsinglestd());
  }
  if (from._internal_dwtorqunit() != 0) {
    _this->_internal_set_dwtorqunit(from._internal_dwtorqunit());
  }
  if (from._internal_dwcolumns() != 0) {
    _this->_internal_set_dwcolumns(from._internal_dwcolumns());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxlimit = from._internal_fmaxlimit();
  uint64_t raw_fmaxlimit;
  memcpy(&raw_fmaxlimit, &tmp_fmaxlimit, sizeof(tmp_fmaxlimit));
  if (raw_fmaxlimit != 0) {
    _this->_internal_set_fmaxlimit(from._internal_fmaxlimit());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrol = from._internal_fcontrol();
  uint64_t raw_fcontrol;
  memcpy(&raw_fcontrol, &tmp_fcontrol, sizeof(tmp_fcontrol));
  if (raw_fcontrol != 0) {
    _this->_internal_set_fcontrol(from._internal_fcontrol());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fshow = from._internal_fshow();
  uint64_t raw_fshow;
  memcpy(&raw_fshow, &tmp_fshow, sizeof(tmp_fshow));
  if (raw_fshow != 0) {
    _this->_internal_set_fshow(from._internal_fshow());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fopttorq = from._internal_fopttorq();
  uint64_t raw_fopttorq;
  memcpy(&raw_fopttorq, &tmp_fopttorq, sizeof(tmp_fopttorq));
  if (raw_fopttorq != 0) {
    _this->_internal_set_fopttorq(from._internal_fopttorq());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxcir = from._internal_fmaxcir();
  uint64_t raw_fmaxcir;
  memcpy(&raw_fmaxcir, &tmp_fmaxcir, sizeof(tmp_fmaxcir));
  if (raw_fmaxcir != 0) {
    _this->_internal_set_fmaxcir(from._internal_fmaxcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fuppercir = from._internal_fuppercir();
  uint64_t raw_fuppercir;
  memcpy(&raw_fuppercir, &tmp_fuppercir, sizeof(tmp_fuppercir));
  if (raw_fuppercir != 0) {
    _this->_internal_set_fuppercir(from._internal_fuppercir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcontrolcir = from._internal_fcontrolcir();
  uint64_t raw_fcontrolcir;
  memcpy(&raw_fcontrolcir, &tmp_fcontrolcir, sizeof(tmp_fcontrolcir));
  if (raw_fcontrolcir != 0) {
    _this->_internal_set_fcontrolcir(from._internal_fcontrolcir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_flowercir = from._internal_flowercir();
  uint64_t raw_flowercir;
  memcpy(&raw_flowercir, &tmp_flowercir, sizeof(tmp_flowercir));
  if (raw_flowercir != 0) {
    _this->_internal_set_flowercir(from._internal_flowercir());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fplus = from._internal_fplus();
  uint64_t raw_fplus;
  memcpy(&raw_fplus, &tmp_fplus, sizeof(tmp_fplus));
  if (raw_fplus != 0) {
    _this->_internal_set_fplus(from._internal_fplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmaxrpm = from._internal_fmaxrpm();
  uint64_t raw_fmaxrpm;
  memcpy(&raw_fmaxrpm, &tmp_fmaxrpm, sizeof(tmp_fmaxrpm));
  if (raw_fmaxrpm != 0) {
    _this->_internal_set_fmaxrpm(from._internal_fmaxrpm());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fcut = from._internal_fcut();
  uint64_t raw_fcut;
  memcpy(&raw_fcut, &tmp_fcut, sizeof(tmp_fcut));
  if (raw_fcut != 0) {
    _this->_internal_set_fcut(from._internal_fcut());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_frpmadj = from._internal_frpmadj();
  uint64_t raw_frpmadj;
  memcpy(&raw_frpmadj, &tmp_frpmadj, sizeof(tmp_frpmadj));
  if (raw_frpmadj != 0) {
    _this->_internal_set_frpmadj(from._internal_frpmadj());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmulti = from._internal_fmulti();
  uint64_t raw_fmulti;
  memcpy(&raw_fmulti, &tmp_fmulti, sizeof(tmp_fmulti));
  if (raw_fmulti != 0) {
    _this->_internal_set_fmulti(from._internal_fmulti());
  }
  if (from._internal_mucoltime() != 0) {
    _this->_internal_set_mucoltime(from._internal_mucoltime());
  }
  if (from._internal_dwmucount() != 0) {
    _this->_internal_set_dwmucount(from._internal_dwmucount());
  }
  if (from._internal_dwmuplus() != 0) {
    _this->_internal_set_dwmuplus(from._internal_dwmuplus());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmumaxtorq = from._internal_fmumaxtorq();
  uint64_t raw_fmumaxtorq;
  memcpy(&raw_fmumaxtorq, &tmp_fmumaxtorq, sizeof(tmp_fmumaxtorq));
  if (raw_fmumaxtorq != 0) {
    _this->_internal_set_fmumaxtorq(from._internal_fmumaxtorq());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fmuduration = from._internal_fmuduration();
  uint64_t raw_fmuduration;
  memcpy(&raw_fmuduration, &tmp_fmuduration, sizeof(tmp_fmuduration));
  if (raw_fmuduration != 0) {
    _this->_internal_set_fmuduration(from._internal_fmuduration());
  }
  if (from._internal_bocoltime() != 0) {
    _this->_internal_set_bocoltime(from._internal_bocoltime());
  }
  if (from._internal_dwoutwellno() != 0) {
    _this->_internal_set_dwoutwellno(from._internal_dwoutwellno());
  }
  if (from._internal_dwbocount() != 0) {
    _this->_internal_set_dwbocount(from._internal_dwbocount());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fbomaxtorq = from._internal_fbomaxtorq();
  uint64_t raw_fbomaxtorq;
  memcpy(&raw_fbomaxtorq, &tmp_fbomaxtorq, sizeof(tmp_fbomaxtorq));
  if (raw_fbomaxtorq != 0) {
    _this->_internal_set_fbomaxtorq(from._internal_fbomaxtorq());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_fboduration = from._internal_fboduration();
  uint64_t raw_fboduration;
  memcpy(&raw_fboduration, &tmp_fboduration, sizeof(tmp_fboduration));
  if (raw_fboduration != 0) {
    _this->_internal_set_fboduration(from._internal_fboduration());
  }
  if (from._internal_dwboplus() != 0) {
    _this->_internal_set_dwboplus(from._internal_dwboplus());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Torque::CopyFrom(const Torque& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:TorqData.Torque)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Torque::IsInitialized() const {
  return true;
}

void Torque::InternalSwap(Torque* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.ftorque_.InternalSwap(&other->_impl_.ftorque_);
  _impl_.frpm_.InternalSwap(&other->_impl_.frpm_);
  _impl_.dwdelplus_.InternalSwap(&other->_impl_.dwdelplus_);
  _impl_.tshow_.InternalSwap(&other->_impl_.tshow_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strmemo_, lhs_arena,
      &other->_impl_.strmemo_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strremark_, lhs_arena,
      &other->_impl_.strremark_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.strbojoint_, lhs_arena,
      &other->_impl_.strbojoint_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Torque, _impl_.dwboplus_)
      + sizeof(Torque::_impl_.dwboplus_)
      - PROTOBUF_FIELD_OFFSET(Torque, _impl_.dwseqno_)>(
          reinterpret_cast<char*>(&_impl_.dwseqno_),
          reinterpret_cast<char*>(&other->_impl_.dwseqno_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Torque::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_DrillData_2eproto_getter, &descriptor_table_DrillData_2eproto_once,
      file_level_metadata_DrillData_2eproto[1]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace TorqData
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::TorqData::ShowInfo*
Arena::CreateMaybeMessage< ::TorqData::ShowInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::ShowInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::TorqData::Torque*
Arena::CreateMaybeMessage< ::TorqData::Torque >(Arena* arena) {
  return Arena::CreateMessageInternal< ::TorqData::Torque >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
